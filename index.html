<!DOCTYPE html>
<html lang="en">
<head>
    <!-- DEV NOTE: Meta tags for mobile + PWA support -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Fallout 76 Item Finder V37</title>

    <!-- DEV NOTE: Leaflet + Clustering + Screenshot Libraries -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- DEV NOTE: Icons & Theme -->
    <link rel="icon" href="https://raw.githubusercontent.com/mrcrazyapps/fallout76-item-finder/main/icon-192.png" sizes="192x192">
    <link rel="icon" href="https://raw.githubusercontent.com/mrcrazyapps/fallout76-item-finder/main/icon-512.png" sizes="512x512">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/mrcrazyapps/fallout76-item-finder/main/icon-192.png">
    <meta name="theme-color" content="#00ff00">

    <style>
        /* DEV NOTE: GLOBAL STYLES — FALLOUT 76 TERMINAL AESTHETIC */
        body { 
            font-family: 'Courier New', monospace; 
            margin: 20px; 
            background-color: #0a2a2a; /* Light Mode: Dark Green */
            color: #00ff00; 
            overflow-x: hidden; 
        }

        h1 { 
            color: #00ff00; 
            text-align: center; 
            text-shadow: 0 0 10px #00ff00; 
            font-size: 2.2em; 
            margin-bottom: 12px; 
        }

        /* DEV NOTE: MAP STYLING — BLACK BACKGROUND, GREEN BORDER */
        #map { 
            height: 750px; 
            max-width: 95%; 
            margin: 0 auto 20px; 
            border: 2px solid #00ff00; 
            box-shadow: 0 0 15px #00ff00; 
            background-color: #000000; /* Map background = black */
            position: relative; 
        }

        /* DEV NOTE: FORM CONTROLS — GREEN BORDERS, BLACK INPUTS */
        .controls { 
            margin-bottom: 20px; 
            text-align: center; 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 10px; 
        }
        input[type="text"], select, textarea { 
            padding: 8px; 
            width: 100%; 
            max-width: 200px; 
            box-sizing: border-box; 
            border: 2px solid #00ff00; 
            border-radius: 0; 
            background-color: #000; 
            color: #00ff00; 
            font-family: 'Courier New', monospace; 
            font-size: 14px;
        }
        textarea { 
            min-height: 80px; 
            resize: vertical; 
        }

        /* DEV NOTE: SEARCH BAR HIGHLIGHT ANIMATION */
        #combinedSearch { 
            max-width: 250px; 
            transition: background-color 0.3s, box-shadow 0.3s; 
        }
        #combinedSearch.grid-highlight, #combinedSearch.item-highlight { 
            background-color: #0a3a0a !important; 
            box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(0, 255, 0, 0.3); 
            animation: pulseSearch 1.5s ease-out; 
        }
        @keyframes pulseSearch { 
            0%, 100% { box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(0, 255, 0, 0.3); } 
            50% { box-shadow: 0 0 25px #00ff00, inset 0 0 15px rgba(0, 255, 0, 0.5); } 
        }

        /* DEV NOTE: BUTTONS — UNIFIED GREEN + BOLD TEXT */
        button { 
            padding: 8px 16px; 
            width: 100%; 
            max-width: 200px; 
            box-sizing: border-box; 
            background-color: #1a3c34; 
            color: #00ff00; 
            border: 2px solid #00ff00; 
            border-radius: 0; 
            cursor: pointer; 
            font-family: 'Courier New', monospace; 
            transition: background-color 0.3s; 
            margin: 5px; 
            font-weight: bold; 
        }
        button:hover { 
            background-color: #00ff00; 
            color: #000; 
        }
        button.reset-btn { 
            background-color: #F7615E !important; 
            color: #000 !important; 
            font-weight: 700; 
        }

        /* DEV NOTE: SPECIAL BUTTONS — SAVE, DELETE, ETC */
        #saveItemBtn { background: #00ff00 !important; color: #000 !important; }
        #shareItemBtn { background: #00b7eb !important; color: #000 !important; }
        #deleteItemBtn { background: #F7615E !important; color: #000 !important; }
        #undoItemBtn { background: #cc8400 !important; color: #000 !important; margin: 8px 8px !important; }
        #duplicateItemBtn { background: #5E99F7 !important; color: #000 !important; }

        /* DEV NOTE: LOCK TOGGLE IN POPUP/MODAL */
        #modalLockToggle, .popup-lock-toggle { 
            color: #ffa500; 
            cursor: pointer; 
        }
        #modalLockToggle:hover, .popup-lock-toggle:hover { 
            color: #00ff00; 
        }

        /* DEV NOTE: TABLE CONTAINER — CENTERED, RESPONSIVE */
        #tableContainer {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            overflow-x: auto !important;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            contain: paint;
            padding: 10px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #0f0;
            border-radius: 8px;
            display: block !important;
        }

        /* DEV NOTE: PAGINATION — PERFECTLY CENTERED ON ALL DEVICES */
        .pagination { 
            display: flex; 
            flex-wrap: wrap;
            justify-content: center; 
            align-items: center; 
            gap: 10px; 
            margin: 15px 0; 
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }

        /* DEV NOTE: COUNTER — YOUR CENTERING FIX RESTORED */
        .counter { 
            width: 200px !important;
            margin: 10px auto !important;
            text-align: center !important;
            font-weight: bold !important;
        }

        /* DEV NOTE: FAKE TABLE HEADER — VISUAL CLARITY */
        #customTableHeader {
            display: table !important;
            width: 100% !important;
            table-layout: fixed !important;
            border-spacing: 0 12px !important;
            margin-bottom: -12px !important;
        }
        #customTableHeader > div {
            display: table-row !important;
            background: rgba(0, 255, 0, 0.2) !important;
            border: 1px solid #0f0 !important;
            border-radius: 8px !important;
        }
        #customTableHeader > div > div {
            display: table-cell !important;
            padding: 10px !important;
            text-align: center !important;
            color: #0f0 !important;
            font-weight: bold !important;
        }

        /* DEV NOTE: REAL TABLE — FLEX LAYOUT FOR MOBILE */
        #locationsTable {
            width: 100% !important;
            border-collapse: separate !important;
            border-spacing: 0 12px !important;
            table-layout: fixed !important;
            margin: 0 !important;
        }
        #locationsTable thead { display: none !important; }
        #locationsTable tbody { display: block !important; width: 100% !important; }
        #locationsTable tbody tr {
            display: flex !important;
            background: rgba(0, 0, 0, 0.4) !important;
            border: 1px solid #0f0 !important;
            border-radius: 8px !important;
            transition: all 0.3s ease !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }
        #locationsTable tbody tr:hover {
            background: rgba(0, 255, 0, 0.08) !important;
            box-shadow: 0 0 8px #0f0 !important;
        }
        #locationsTable tbody tr.glowing {
            background: rgba(0, 255, 0, 0.15) !important;
            box-shadow: 0 0 12px #0f0, 0 0 20px #0f0 !important;
            animation: tablePulse 1.5s infinite ease-in-out !important;
            border: 2px solid #00ff88 !important;
        }
        @keyframes tablePulse {
            0%, 100% { box-shadow: 0 0 12px #0f0, 0 0 20px #0f0; }
            50% { box-shadow: 0 0 18px #0f0, 0 0 30px #0f0; }
        }

        /* DEV NOTE: TABLE CELL FLEX SIZING */
        #locationsTable tbody td {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px !important;
            word-wrap: break-word !important;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: normal !important;
            word-break: break-word !important;
            overflow-wrap: break-word !important;
        }
        #locationsTable tbody td:nth-child(1) { flex: 0.6; }   /* Lock */
        #locationsTable tbody td:nth-child(2) { flex: 0.9; }   /* Icon */
        #locationsTable tbody td:nth-child(3) { flex: 1.5; }   /* Category */
        #locationsTable tbody td:nth-child(4) { 
            flex: 3; 
            justify-content: flex-start !important;
            padding-left: 15px !important;
        }

        /* DEV NOTE: ICONS & LOCK TOGGLE */
        .icon-circle { 
            width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto; font-size: 16px; font-weight: bold; color: #000;
        }
        .text-location { 
            background: #000; color: #fff; padding: 2px 6px; border: 1px solid #0f0; border-radius: 3px; font-size: 11px; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; margin: 0 auto;
        }
        .lock-toggle { font-size: 18px; cursor: pointer; display: block; margin: 0 auto; }

        /* DEV NOTE: MODALS — FULLSCREEN, GREEN BORDER */
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 10000; 
            left: 0; top: 0; 
            width: 100%; height: 100%; 
            overflow: hidden; 
            background-color: rgba(0, 42, 42, 0.8); 
        }
        .modal-content { 
            background-color: #1a3c34; 
            margin: 8% auto; 
            padding: 16px; 
            border: 2px solid #00ff00; 
            width: 100%; 
            max-width: 360px; 
            box-sizing: border-box; 
            border-radius: 0; 
            color: #00ff00; 
            font-family: 'Courier New', monospace; 
            overflow-y: auto; 
            max-height: 80vh; 
            -webkit-overflow-scrolling: touch; 
        }
        .close { 
            color: #00ff00; 
            float: right; 
            font-size: 24px; 
            font-weight: bold; 
            line-height: 1; 
            cursor: pointer; 
        }
        .close:hover { color: #0a2a2a; }

        /* DEV NOTE: MODAL BUTTONS — CENTERED & WRAPPED */
        #itemModal .modal-content > div:last-child {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 12px;
        }

        /* DEV NOTE: MARKER CLUSTERING */
        .marker-cluster div { 
            width: 30px; height: 30px; margin-left: 5px; margin-top: 5px; text-align: center; border-radius: 15px; 
            font: bold 12px/30px "Helvetica Neue", Arial, Helvetica, sans-serif; 
            background-color: #ffff00; color: #000000; 
        }

        /* DEV NOTE: GRID LINES & LABELS */
        .grid-line { 
            pointer-events: none; 
            stroke: rgba(0, 255, 0, 0.35); 
            stroke-width: 1; 
            stroke-dasharray: 4, 4; 
        }
        .grid-label { 
            font-family: 'Courier New', monospace; 
            font-size: 16px; 
            font-weight: bold; 
            fill: #00ff00; 
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; 
            pointer-events: none; 
            text-anchor: middle; 
            dominant-baseline: central; 
        }

        /* DEV NOTE: GRID NOTIFICATION POPUP */
        #gridNotification { 
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            background: #0a3a0a; 
            color: #00ff00; 
            padding: 14px 22px; 
            border: 2px solid #00ff00; 
            border-radius: 0; 
            font-weight: bold; 
            font-family: 'Courier New', monospace; 
            font-size: 15px; 
            box-shadow: 0 0 20px #00ff00, 0 0 40px rgba(0, 255, 0, 0.3); 
            z-index: 10000; 
            opacity: 0; 
            transform: translateY(20px); 
            transition: opacity 0.4s ease, transform 0.3s ease; 
            pointer-events: none; 
        }
        #gridNotification.show { 
            opacity: 1; 
            transform: translateY(0); 
        }

        /* DEV NOTE: DARK MODE — FULL BLACK TERMINAL */
        body.dark-mode {
            background-color: #000000 !important; /* FULL PAGE BLACK */
        }
        body.dark-mode #searchBar,
        body.dark-mode #buttonGroup,
        body.dark-mode #tableContainer,
        body.dark-mode .modal-content,
        body.dark-mode #xpStatus,
        body.dark-mode h1, body.dark-mode h2,
        body.dark-mode .counter {
            background-color: #000000 !important;
            border-color: #00ff00 !important;
        }
        body.dark-mode input,
        body.dark-mode select,
        body.dark-mode textarea,
        body.dark-mode button,
        body.dark-mode .counter,
        body.dark-mode h1, body.dark-mode h2 {
            color: #00ff00 !important;
        }
        body.dark-mode button:hover {
            background-color: #00ff00 !important;
            color: #000 !important;
            box-shadow: 0 0 10px #00ff00 !important;
        }
        body.dark-mode .grid-line {
            stroke: rgba(0, 255, 0, 0.4) !important;
        }

        /* DEV NOTE: LEAFLET POPUP = ALWAYS LIGHT FALLOUT 76 STYLE */
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background-color: #1a3c34 !important;
            color: #00ff00 !important;
            font-family: 'Courier New', monospace !important;
            border: 2px solid #00ff00 !important;
        }
        body.dark-mode .leaflet-popup-content-wrapper,
        body.dark-mode .leaflet-popup-tip {
            background-color: #1a3c34 !important;
            color: #00ff00 !important;
        }

        /* DEV NOTE: ZOOM BUTTONS — FALLOUT 76 STYLE + SAFE POSITION (60px, 60px) */
        .leaflet-control-zoom {
            top: 60px !important;
            left: 60px !important;
            margin: 0 !important;
        }
        .leaflet-control-zoom a {
            background-color: #000000 !important;
            color: #00ff00 !important;
            border: 2px solid #00ff00 !important;
            font-family: 'Courier New', monospace !important;
            font-weight: bold !important;
            text-shadow: 0 0 5px #00ff00 !important;
            box-shadow: 0 0 8px #00ff00 !important;
            border-radius: 0 !important;
            width: 30px !important;
            height: 30px !important;
            line-height: 26px !important;
            font-size: 18px !important;
            text-align: center !important;
        }
        .leaflet-control-zoom a:hover {
            background-color: #00ff00 !important;
            color: #000000 !important;
            box-shadow: 0 0 15px #00ff00, inset 0 0 10px #00ff00 !important;
        }

        /* DEV NOTE: MARKER GLOW ANIMATION */
        .custom-icon.glowing { 
            box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00 !important; 
            animation: glowPulse 1.5s infinite ease-in-out;
        }
        @keyframes glowPulse {
            0%, 100% { box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
            50% { box-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00; }
        }

        /* DEV NOTE: MARKER BACKGROUND — ROUND */
        .marker-background { 
            width: 30px; height: 30px; 
            border-radius: 50% !important; 
            display: flex; align-items: center; justify-content: center; 
            background-color: #808080; 
        }

        /* DEV NOTE: CATEGORY LIST — VERTICAL + SPACED */
        #categoryCheckboxes label {
            display: block !important;
            margin: 8px 0 !important;
            padding: 6px !important;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        /* DEV NOTE: NUKA-COLA LINK — READABLE */
        .small a {
            color: #00ff00 !important;
            text-decoration: underline;
            font-weight: bold;
        }
        .small a:hover {
            color: #00ff88 !important;
            text-shadow: 0 0 8px #00ff00;
        }

        /* DEV NOTE: MOBILE RESPONSIVENESS */
        @media (max-width: 768px) {
            #map { height: 600px; max-width: 100%; }
            .controls { flex-direction: column; align-items: center; }
            input[type="text"], select, textarea, button { 
                width: 100%; max-width: 100%; margin: 5px 0; 
                font-size: clamp(14px, 4vw, 16px); 
                padding: clamp(10px, 2vw, 12px); 
            }
            #combinedSearch { max-width: 100%; }
            .modal-content { max-width: 90%; padding: 12px; font-size: clamp(14px, 3.5vw, 16px); max-height: 80vh; overflow-y: auto; -webkit-overflow-scrolling: touch; }
            .close { font-size: clamp(20px, 5vw, 22px); }
            #gridNotification { bottom: 10px; right: 10px; font-size: 13px; padding: 10px 16px; box-shadow: 0 0 15px #00ff00; }
            #tableContainer { padding: 8px; }
            #customTableHeader > div > div,
            #locationsTable tbody td {
                font-size: 11px !important;
                padding: 6px 4px !important;
            }
            #locationsTable tbody td:nth-child(4) {
                font-size: 10px !important;
                white-space: normal !important;
                line-height: 1.3 !important;
                word-break: break-word !important;
            }
            .icon-circle { width: 24px !important; height: 24px !important; font-size: 13px !important; }
            .text-location { font-size: 9px !important; max-width: 80px !important; }
            .leaflet-control-zoom {
                top: 50px !important;
                left: 50px !important;
            }
        }

        /* DEV NOTE: NUKE CODES EASTER EGG */
        .nuke-emoji-wrapper { text-align: center; margin: 12px 0; }
        .nuke-emoji-btn { 
            display: inline-block; 
            padding: 14px 18px; 
            background: #001100; 
            color: #00ff00 !important; 
            font-size: 3.2em; 
            text-decoration: none; 
            border: 3px solid #00ff00; 
            border-radius: 50%; 
            box-shadow: 0 0 14px #00ff00; 
            transition: all 0.25s ease; 
            cursor: pointer; 
        }
        .nuke-emoji-btn:hover { 
            background: #002200; 
            transform: scale(1.12) rotate(8deg); 
            box-shadow: 0 0 22px #00ff00, 0 0 34px #00ff00; 
        }
        .nuke-emoji-btn:active { transform: scale(0.96); }

        /* DEV NOTE: VOICE SEARCH COMPATIBILITY */
        #voiceSearchBtn[disabled], #voiceSearchBtn[style*="opacity: 0.6"] { 
            pointer-events: auto !important; 
        }

        /* DEV NOTE: UI LOADING FLASH PREVENTION */
        #searchBar, #buttonGroup, #belowMapControls, #toolsToggleRow, #topBar {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .map-ready #searchBar, .map-ready #buttonGroup,
        .map-ready #belowMapControls, .map-ready #toolsToggleRow,
        .map-ready #topBar {
            visibility: visible; opacity: 1;
        }

        /* DEV NOTE: CUSTOM UI LAYOUT FIXES */
        .top-bar.hidden { display: none; }
        .tools-toggle-row { display: flex; justify-content: center; margin: 10px 0; }
        .button-group.hidden { display: none !important; }
        #lockAllBtn { display: none; margin: 5px; }
        #toggleTableBtn { display: none !important; }

        /* DEV NOTE: POPUP ARROW EVEN CLOSER */
        .leaflet-popup {
            margin-bottom: 25px !important;
        }
        .leaflet-popup-tip {
            margin-top: -6px !important;
        }
    </style>
</head>
<body>
    <!-- DEV NOTE: TITLE TOGGLE BUTTON -->
    <div style="text-align:center; margin-bottom:8px;">
        <button id="toggleTitleBtn" style="padding:2px 6px; font-size:0.9em; max-width:40px; margin:0 auto;">-</button>
    </div>
    <h1 id="mainTitle">The Fallout 76 Item Finder! Quickly log items while exploring Appalachia.</h1>
  
    <!-- DEV NOTE: SEARCH BAR + VOICE + CATEGORY FILTER -->
    <div id="searchBar" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:center; margin:10px auto; padding:10px; background:rgba(0,0,0,0.5); border:1px solid #0f0; border-radius:8px; max-width:90%;">
        <input type="text" id="combinedSearch" placeholder="desc/cate/grid.." style="flex:1; min-width:200px; padding:8px; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;">
        <button id="clearSearchBtn" style="background:none; border:none; color:#00ff00; font-size:18px; cursor:pointer; display:none; padding:0 8px;">X</button>
        <select id="categoryFilter" style="padding:8px; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;"><option value="">All Categories</option></select>
        <button id="toggleCategoryModalBtn" style="padding:8px 12px; background:#1a3c34; color:#0f0; border:1px solid #0f0; border-radius:4px;">Toggle Categories</button>
    </div>
  
    <!-- DEV NOTE: MAIN MAP CONTAINER -->
    <div id="map"></div>
  
    <!-- DEV NOTE: TOOLS PANEL — ALL BUTTONS -->
    <div class="tools-container" id="buttonGroup" style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin:10px auto; padding:10px; background:rgba(0,0,0,0.5); border:1px solid #0f0; border-radius:8px; max-width:90%;">
        <button id="voiceSearchBtn">Voice Search</button>
        <button id="toggleClusterBtn">Clustering: On</button>
        <button id="toggleMapBtn">Show No-Name Map</button>
        <button id="toggleGridBtn">Grid: Off</button>
        <button id="toggleButtonGroup">Hide Tools</button>
        <button id="howToUseBtn">How to Use</button>
        <button id="nukeCodesBtn">Nuke Codes</button>
        <button id="toggleSoundsBtn">Sounds: On</button>
        <button id="exportJsonBtn">Export Markers</button>
        <button id="importBtn">Import Markers</button>
        <button id="downloadCommunityBtn">Update Community Map</button>
        <button id="undoImportBtn" style="display:none;">UNDO IMPORT</button>
        <button id="saveMapJpegBtn">Save Map as JPEG</button>
        <button id="toggleDarkModeBtn">Dark Mode: Off</button>
        <button id="lockAllBtn">Lock All</button>
    </div>
  
    <!-- DEV NOTE: XP PROGRESS BAR -->
    <div id="xpStatus" style="text-align:center; margin:10px; color:#0f0; font-weight:bold;">
        Explorer Level: <span id="levelSpan">1</span><br>
        XP: <progress id="xpProgress" value="0" max="1000" style="width:200px;"></progress> <span id="xpText">0 / 1000</span>
    </div>
  
    <!-- DEV NOTE: CONTENT INVENTORY TABLE -->
    <h2 style="text-align:center; margin:15px 0 5px;">Content Inventory</h2>
    <p id="counter" class="counter"></p>
  
    <div id="tableContainer" style="margin:0 auto 20px; max-width:90%; background:rgba(0,0,0,0.7); border:1px solid #0f0; border-radius:8px; padding:10px;">
        <div class="pagination">
            <button id="prevPageBtn" disabled>Prev</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPageBtn" disabled>Next</button>
        </div>
        <table id="locationsTable" style="width:100%; border-collapse:collapse; color:#0f0;">
            <tbody></tbody>
        </table>
    </div>
  
    <!-- DEV NOTE: GRID NOTIFICATION POPUP -->
    <div id="gridNotification"></div>
  
    <!-- DEV NOTE: ITEM LOGGING MODAL -->
    <div id="itemModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2 id="modalTitle">Log Item <span id="modalLockToggle" style="font-size:22px; cursor:pointer; margin-left:10px;">LOCKED</span></h2>
            <label>Category:</label>
            <select id="itemCategory"></select>
            <label>Description:</label>
            <textarea id="itemDesc" placeholder="Enter item and location details or leave blank auto puts gid location"></textarea>
            <div style="margin-top:12px; text-align:center;">
                <button id="saveItemBtn">Save</button>
                <button id="shareItemBtn">Share Link</button>
                <button id="deleteItemBtn" style="display:none;">Delete</button>
                <button id="undoItemBtn" style="display:none;">Undo Delete</button>
                <button id="duplicateItemBtn" style="display:none;">Duplicate</button>
            </div>
        </div>
    </div>
  
    <!-- DEV NOTE: HOW TO USE MODAL — NO TABS, NO SHORTCUT -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h1>Fallout 76 Item Finder Info</h1>

            <p><strong>Double-tap</strong> (mobile) or <strong>double-click</strong> the map to log an item.</p>
            <p><strong>New markers</strong> are <strong>LOCKED</strong> and <strong>glow for 2 minutes</strong>.</p>
            <p><strong>Unlock</strong> to drag — drop auto-saves + glows again!</p>
            <p><strong>Lock</strong> to protect from accidental moves.</p>
            <p><strong>Right-click</strong> or <strong>long-press</strong> markers to <strong>edit, delete, or duplicate</strong> (undo available).</p>
            <p><strong>Left-click</strong> any row in the <strong>Content Inventory</strong> to zoom to marker.</p>
            <p><strong>Right-click</strong> row to open <strong>Edit menu + zoom</strong>.</p>
            <p>Use the <strong>search bar</strong> to filter by description, category, or grid.</p>
            <p>Toggle between <strong>named</strong> and <strong>no-name</strong> maps with the button.</p>
            <p>Click anywhere to see <strong>grid coordinate</strong> (e.g., C4) in a green popup.</p>
            <p>Toggle <strong>grid overlay</strong> with the Grid button.</p>
            <p>Create <strong>custom categories</strong> in the Toggle Categories menu.</p>
            <p><strong>Export</strong> your markers or <strong>import</strong> others (duplicates skipped).</p>
            <p><strong>Save a JPEG</strong> of your current map view.</p>
            <p><strong>Gain XP</strong> for logging items — level up like in Fallout 76!</p>
            <p><strong>Lose XP</strong> when deleting items.</p>
            <p>For <strong>offline use</strong>: Save locally and open in Chrome/Firefox/Safari.</p>
            <p>Internet needed <strong>only on first load</strong> for map & libraries.</p>
            <p><strong>Update Community Map</strong> regularly for latest version.</p>

            <div style="text-align:center; margin:15px 0;">
                <button id="resetAppBtn" class="reset-btn">Reset App (for debugging only)</button>
            </div>

            <p class="small"><br>Love the Item Finder? Support MrCrazy with a <a href="https://buymeacoffee.com/mrcrazy" target="_blank">Nuka-Cola</a>!</p>
            <p class="small" id="appVersionText">The Fallout 76 Item Finder Map Version 37 Made By MrCrazy</p>
        </div>
    </div>

    <!-- DEV NOTE: NUKE CODES MODAL — STANDALONE -->
    <div id="nukeCodesModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h1>Nuke Codes</h1>
            <div class="nuke-emoji-wrapper">
                <a href="https://www.falloutbuilds.com/fo76/nuke-codes/" target="_blank" rel="noopener noreferrer" class="nuke-emoji-btn" title="Launch codes – click the rocket">ROCKET</a>
            </div>
            <p style="text-align:center; margin-top:20px;">
                <strong>Weekly launch codes — always up to date!</strong>
            </p>
        </div>
    </div>
  
    <!-- DEV NOTE: CATEGORY TOGGLE MODAL -->
    <div id="categoryToggleModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2>Toggle Categories</h2>
            <div style="margin-bottom:10px; text-align:center;">
                <button id="selectAllBtn">Select All</button>
                <button id="deselectAllBtn">Deselect All</button>
                <button id="createCategoryBtn">Create Category</button>
                <button id="deleteCategoryBtn">Delete Category</button>
            </div>
            <div id="categoryCheckboxes"></div>
            <button id="closeCategoryToggleBtn">Close</button>
        </div>
    </div>
  
    <!-- DEV NOTE: CREATE CATEGORY MODAL — SPACED & CLEAN -->
    <div id="createCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2>Create New Category</h2>
            <label style="display:block; margin:10px 0 4px;">Category Name:</label>
            <input type="text" id="newCategoryName" placeholder="Enter category name" style="width:100%; padding:8px; margin-bottom:10px;">
            <label style="display:block; margin:10px 0 4px;">Emoji (only one):</label>
            <input type="text" id="newCategoryEmoji" placeholder="Paste emoji" maxlength="2" inputmode="text" style="width:100%; padding:8px; margin-bottom:10px;">
            <p class="small">Paste one emoji. Only emojis allowed.</p>
            <div style="margin-top:12px; text-align:center;">
                <button id="saveCategoryBtn">Save Category</button>
            </div>
        </div>
    </div>
  
    <!-- DEV NOTE: DELETE CATEGORY MODAL -->
    <div id="deleteCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2>Delete Category</h2>
            <label>Select Category to Delete:</label>
            <select id="deleteCategorySelect">
                <option value="">Select a custom category</option>
            </select>
            <p class="small">Deleting a category will reassign all its markers to "misc".</p>
            <div style="margin-top:12px; text-align:center;">
                <button id="confirmDeleteCategoryBtn">Delete Category</button>
            </div>
        </div>
    </div>

<script>
/* DEV NOTE: MAIN APP LOGIC — FULLY COMMENTED */
document.addEventListener('DOMContentLoaded', function() {
    (function() {
        /* DEV NOTE: STORAGE KEYS */
        const STORAGE_KEY = 'fallout76_locations';
        const CUSTOM_CATEGORIES_KEY = 'fallout76_custom_categories';
        const MAP_VERSION_KEY = 'fallout76_map_version';
        const TERMS_ACCEPTED_KEY = 'fallout76_terms_accepted';
        const UPDATE_VERSION_KEY = 'fallout76_last_update_seen';
        const CURRENT_UPDATE_VERSION = 'v37-final';
        const APP_VERSION = "37";

        /* DEV NOTE: SOUND SYSTEM — 8-BIT FALLOUT VIBES */
        let soundsEnabled = localStorage.getItem('soundsEnabled') !== 'false';
        const baseSounds = {
            click: new Audio("https://rpg.hamsterrepublic.com/wiki-images/8/84/Select8-Bit.ogg"),
            type: new Audio("https://rpg.hamsterrepublic.com/wiki-images/3/3a/Thip.ogg"),
            error: new Audio("https://rpg.hamsterrepublic.com/wiki-images/1/12/Ping-da-ding-ding-ding.ogg"),
            duplicate: new Audio("https://rpg.hamsterrepublic.com/wiki-images/0/0b/Robot_2.ogg"),
            saving: new Audio("https://rpg.hamsterrepublic.com/wiki-images/9/9c/Robot_1.ogg"),
            undo: new Audio("https://rpg.hamsterrepublic.com/wiki-images/d/d7/Oddbounce.ogg"),
            delete: new Audio("https://rpg.hamsterrepublic.com/wiki-images/0/04/TextboxBloop8-Bit.ogg"),
            levelUp: new Audio("https://rpg.hamsterrepublic.com/wiki-images/d/d5/Menu8-Bit.ogg"),
            modalClose: new Audio("https://rpg.hamsterrepublic.com/wiki-images/8/8e/Confirm8-Bit.ogg"),
            selectcategory: new Audio("https://rpg.hamsterrepublic.com/wiki-images/a/a8/Rolling_Switch.ogg")
        };
        Object.values(baseSounds).forEach(s => { s.volume = 0.15; });
        function playSound(type) {
            if (soundsEnabled && baseSounds[type]) {
                baseSounds[type].currentTime = 0;
                baseSounds[type].play().catch(() => {});
            }
        }

        /* DEV NOTE: ID & CID GENERATION */
        function generateUniqueId() { return 'id-' + crypto.randomUUID(); }
        function generateCid(loc) {
            const desc = (loc.desc || '').toString().toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, '_');
            const lat = Math.round(loc.lat);
            const lng = Math.round(loc.lng);
            return `${loc.category}_${desc}_${lat}_${lng}`;
        }

        /* DEV NOTE: LOAD LOCATIONS FROM LOCALSTORAGE */
        let locations = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
        locations.forEach(loc => {
            if (!loc.id) loc.id = generateUniqueId();
            if (!loc.cid && loc.category && loc.desc && loc.lat && loc.lng) {
                loc.cid = generateCid(loc);
            }
            if (loc.locked === undefined) loc.locked = false;
        });
        localStorage.setItem(STORAGE_KEY, JSON.stringify(locations));

        /* DEV NOTE: CUSTOM CATEGORIES & COMMUNITY VERSION */
        let customCategories = JSON.parse(localStorage.getItem(CUSTOM_CATEGORIES_KEY)) || {};
        let communityVersion = localStorage.getItem(MAP_VERSION_KEY) || "1.0";
        let termsAccepted = localStorage.getItem(TERMS_ACCEPTED_KEY) === 'true';
        let lastImportBackup = null;

        /* DEV NOTE: DEFAULT CATEGORIES & ICONS */
        const defaultCategoryIcons = {
            'weapons': 'GUN', 'armor': 'SHIELD', 'aid': 'SYRINGE', 'food/drink': 'FORK', 'ammunition': 'EXPLOSION',
            'apparel': 'SHIRT', 'plans': 'SCROLL', 'junk': 'TRASH', 'holotapes': 'DISC', 'misc': 'NOTE',
            'plants': 'LEAF', 'eggs': 'EGG', 'creatures': 'WOLF', 'vendors': 'MONEY', 'exchanges': 'SCALES',
            'vaults': 'GEAR', 'power armor': 'ROBOT', 'fusion core': 'BATTERY', 'nuke drop zones': 'RADIOACTIVE',
            'nuke silos': 'ROCKET', 'magazines': 'BOOK', 'bobbleheads': 'DOLL', 'safe locations': 'SAFE',
            'terminal locations': 'COMPUTER', 'treasure maps': 'MAP', 'resource deposits': 'PICKAXE',
            'fishing locations': 'FISH', 'workshops': 'WRENCH', 'train stations': 'TRAIN', 'town locations': 'SCHOOL',
            'event locations': 'PARTY', 'named locations': 'FLAG', 'regions': 'PIN'
        };
        let categoryIcons = { ...defaultCategoryIcons, ...customCategories };

        /* DEV NOTE: CATEGORY COLORS */
        const defaultCategoryColors = {
            'weapons': '#ff4444', 'armor': '#4682b4', 'aid': '#32cd32', 'food/drink': '#adff2f',
            'ammunition': '#ff8c00', 'apparel': '#dda0dd', 'plans': '#a0522d', 'junk': '#808080',
            'holotapes': '#f0e68c', 'misc': '#f0e68c', 'plants': '#228b22', 'eggs': '#f5f5dc',
            'creatures': '#8b0000', 'vendors': '#ffd700', 'exchanges': '#20b2aa', 'vaults': '#4682b4',
            'power armor': '#b22222', 'fusion core': '#ff4500', 'nuke drop zones': '#ff0000',
            'nuke silos': '#dc143c', 'magazines': '#ff69b4', 'bobbleheads': '#00b7eb',
            'treasure maps': '#d2b48c', 'resource deposits': '#696969', 'fishing locations': '#1e90ff',
            'workshops': '#b8860b', 'train stations': '#a9a9a9', 'town locations': '#228b22',
            'regions': '#00ff00', 'named locations': '#ffffff'
        };
        let categoryColors = { ...defaultCategoryColors };

        /* DEV NOTE: LEAFLET MAP INITIALIZATION — minZoom = -2 */
        const map = L.map('map', { 
            crs: L.CRS.Simple, 
            minZoom: -2,    // More zoom out
            maxZoom: 4, 
            zoomControl: false  // We'll add it manually
        });
        const imageBounds = [[0, 0], [4096, 4096]];
        const mapUrls = {
            named: 'https://i.postimg.cc/HpqMVWjB/Mappalachia-Map-of-Appalachia.jpg',
            noName: 'https://i.postimg.cc/y6W7JMKB/Mappalachia-Map-of-Appalachia-no-name.jpg'
        };
        let currentMap = localStorage.getItem('currentMap') || 'named';
        let imageOverlay = L.imageOverlay(mapUrls[currentMap], imageBounds).addTo(map);
        map.fitBounds(imageBounds);

        // DEV NOTE: Add zoom control at (60px, 60px) — OUTSIDE FLY MODE
        L.control.zoom({ position: 'topleft' }).addTo(map);

        /* DEV NOTE: MARKER CLUSTERING */
        const clusteredMarkers = L.markerClusterGroup({ maxClusterRadius: 30, disableClusteringAtZoom: 2 });
        const nonClusteredMarkers = L.layerGroup();
        map.addLayer(clusteredMarkers);
        map.addLayer(nonClusteredMarkers);

        /* DEV NOTE: STATE VARIABLES */
        let lastDeleted = null;
        let currentIndex = -1;
        let tempLatLng = { lat: 0, lng: 0 };
        let clusteringEnabled = localStorage.getItem('clusteringEnabled') !== 'false';
        let gridEnabled = localStorage.getItem('gridEnabled') === 'true';
        let activeCategories = new Set(
            localStorage.getItem('activeCategories')
                ? JSON.parse(localStorage.getItem('activeCategories'))
                : Object.keys(defaultCategoryIcons)
        );
        let level = parseInt(localStorage.getItem('fo76_level')) || 1;
        let xp = parseInt(localStorage.getItem('fo76_xp')) || 0;
        const xpPerLevel = 1000;
        const xpPerMarker = 100;
        const pageSize = 100;
        let tablePage = parseInt(localStorage.getItem('tablePage')) || 1;
        let currentSearch = localStorage.getItem('currentSearch') || '';
        let currentCategoryFilter = localStorage.getItem('currentCategoryFilter') || '';
        let darkMode = localStorage.getItem('darkMode') === 'true';
        let gridLayer = L.layerGroup().addTo(map);
        let isDraggingAny = false;
        let titleVisible = localStorage.getItem('titleVisible') !== 'false';
        let toolsVisible = localStorage.getItem('toolsVisible') !== 'false';

        /* DEV NOTE: CREATE NEW LOCATION (AUTO-LOCKED) */
        function createNewLocation(lat, lng, category, desc) {
            return {
                id: generateUniqueId(),
                lat, lng,
                category, desc,
                icon: categoryIcons[category] || 'UNKNOWN',
                addedTime: Date.now(),
                userEdited: true,
                locked: true,
                cid: generateCid({ category, desc, lat, lng })
            };
        }

        /* DEV NOTE: GRID DRAWING */
        function drawGrid() {
            gridLayer.clearLayers();
            if (!gridEnabled) return;
            const gridSize = 10;
            const cellSize = 4096 / gridSize;
            for (let i = 0; i <= gridSize; i++) {
                const x = i * cellSize;
                L.polyline([[0, x], [4096, x]], { className: 'grid-line', color: '#0f0', weight: 1, opacity: 0.5 }).addTo(gridLayer);
                const y = i * cellSize;
                L.polyline([[y, 0], [y, 4096]], { className: 'grid-line', color: '#0f0', weight: 1, opacity: 0.5 }).addTo(gridLayer);
            }
            const letters = 'ABCDEFGHIJ'.split('');
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const centerX = col * cellSize + cellSize / 2;
                    const centerY = row * cellSize + cellSize / 2;
                    const label = `${letters[col]}${row + 1}`;
                    L.marker([centerY, centerX], {
                        icon: L.divIcon({ className: 'grid-label', html: label, iconSize: [30, 30], iconAnchor: [15, 15] })
                    }).addTo(gridLayer);
                }
            }
        }

        /* DEV NOTE: GRID CONVERSION FUNCTIONS */
        function getGridFromLatLng(lat, lng) {
            const gridSize = 10;
            const cellSize = 4096 / gridSize;
            const col = Math.floor(lng / cellSize);
            const row = Math.floor(lat / cellSize);
            const letters = 'ABCDEFGHIJ';
            if (col >= 0 && col < letters.length && row >= 0 && row < gridSize) {
                return `${letters[col]}${row + 1}`;
            }
            return null;
        }

        function getLatLngFromGrid(grid) {
            const match = grid.toUpperCase().match(/^([A-J])(\d+)$/);
            if (!match) return null;
            const letters = 'ABCDEFGHIJ';
            const col = letters.indexOf(match[1]);
            const row = parseInt(match[2], 10) - 1;
            if (col === -1 || row < 0 || row >= 10) return null;
            const gridSize = 10;
            const cellSize = 4096 / gridSize;
            const centerX = col * cellSize + cellSize / 2;
            const centerY = row * cellSize + cellSize / 2;
            return { lat: centerY, lng: centerX };
        }

        /* DEV NOTE: GRID NOTIFICATION */
        function showGridNotification(grid) {
            const notif = document.getElementById('gridNotification');
            if (!notif) return;
            notif.textContent = `Grid: ${grid}`;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 3000);
        }

        /* DEV NOTE: SEARCH HIGHLIGHT ANIMATION */
        function highlightSearchBar(type = 'grid') {
            const search = document.getElementById('combinedSearch');
            if (!search) return;
            search.classList.remove('grid-highlight', 'item-highlight');
            search.classList.add(type === 'grid' ? 'grid-highlight' : 'item-highlight');
            setTimeout(() => search.classList.remove(type === 'grid' ? 'grid-highlight' : 'item-highlight'), 1500);
        }

        /* DEV NOTE: EMOJI VALIDATION */
        function isValidEmoji(str) {
            if (!str || str.length === 0) return false;
            const emojiRegex = /^[\p{Emoji}]+$/u;
            return emojiRegex.test(str.trim());
        }

        /* DEV NOTE: AUTO-ADD GRID TO DESCRIPTION */
        function updateDescWithGrid(desc, lat, lng) {
            const grid = getGridFromLatLng(lat, lng);
            const x = Math.round(lng);
            const y = Math.round(lat);
            const newCoords = grid ? `Grid ${grid} (X: ${x}, Y: ${y})` : `X: ${x}, Y: ${y}`;
            const regex = /(Grid [A-J]\d+ \(X: \d+, Y: \d+\))|(X: \d+, Y: \d+)/;
            if (regex.test(desc)) {
                return desc.replace(regex, newCoords);
            }
            return desc + '\n' + newCoords;
        }

        /* DEV NOTE: DOM ELEMENT REFERENCES */
        const itemModal = document.getElementById('itemModal');
        const deleteBtn = document.getElementById('deleteItemBtn');
        const undoBtn = document.getElementById('undoItemBtn');
        const duplicateBtn = document.getElementById('duplicateItemBtn');
        const shareItemBtn = document.getElementById('shareItemBtn');
        const modalTitle = document.getElementById('modalTitle');
        const itemCategorySelect = document.getElementById('itemCategory');
        const itemDescInput = document.getElementById('itemDesc');
        const toggleSoundsBtn = document.getElementById('toggleSoundsBtn');
        const toggleClusterBtn = document.getElementById('toggleClusterBtn');
        const toggleMapBtn = document.getElementById('toggleMapBtn');
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const toggleButtonGroup = document.getElementById('toggleButtonGroup');
        const buttonGroup = document.getElementById('buttonGroup');
        const combinedSearch = document.getElementById('combinedSearch');
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const categoryFilter = document.getElementById('categoryFilter');
        const levelSpan = document.getElementById('levelSpan');
        const xpProgress = document.getElementById('xpProgress');
        const xpText = document.getElementById('xpText');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const tableContainer = document.getElementById('tableContainer');
        const counter = document.getElementById('counter');
        const categoryToggleModal = document.getElementById('categoryToggleModal');
        const toggleCategoryModalBtn = document.getElementById('toggleCategoryModalBtn');
        const howToUseBtn = document.getElementById('howToUseBtn');
        const nukeCodesBtn = document.getElementById('nukeCodesBtn');
        const exportBtn = document.getElementById('exportJsonBtn');
        const importBtn = document.getElementById('importBtn');
        const downloadCommunityBtn = document.getElementById('downloadCommunityBtn');
        const saveJpegBtn = document.getElementById('saveMapJpegBtn');
        const resetAppBtn = document.getElementById('resetAppBtn');
        const newCategoryEmoji = document.getElementById('newCategoryEmoji');
        const toggleDarkModeBtn = document.getElementById('toggleDarkModeBtn');
        const voiceSearchBtn = document.getElementById('voiceSearchBtn');
        const undoImportBtn = document.getElementById('undoImportBtn');
        const lockAllBtn = document.getElementById('lockAllBtn');

        // NEW: Nuke Codes Modal
        const nukeCodesModal = document.getElementById('nukeCodesModal');

        /* DEV NOTE: INITIALIZE BUTTON TEXT */
        if (toggleSoundsBtn) toggleSoundsBtn.textContent = soundsEnabled ? 'Sounds: On' : 'Sounds: Off';
        if (toggleClusterBtn) toggleClusterBtn.textContent = `Clustering: ${clusteringEnabled ? 'On' : 'Off'}`;
        if (toggleMapBtn) toggleMapBtn.textContent = currentMap === 'named' ? 'Show No-Name Map' : 'Show Named Map';
        if (toggleGridBtn) toggleGridBtn.textContent = `Grid: ${gridEnabled ? 'On' : 'Off'}`;
        if (toggleButtonGroup) toggleButtonGroup.textContent = toolsVisible ? 'Hide Tools' : 'Show Tools';
        if (combinedSearch) combinedSearch.value = currentSearch;
        if (categoryFilter) categoryFilter.value = currentCategoryFilter;
        document.body.classList.toggle('dark-mode', darkMode);
        if (toggleDarkModeBtn) {
            toggleDarkModeBtn.textContent = darkMode ? 'Dark Mode: On' : 'Dark Mode: Off';
        }

        /* DEV NOTE: LOCK ALL BUTTON VISIBILITY */
        function updateLockAllBtn() {
            const hasUnlocked = locations.some(l => !l.locked);
            if (lockAllBtn) {
                lockAllBtn.style.display = hasUnlocked ? 'inline-block' : 'none';
                lockAllBtn.textContent = hasUnlocked ? 'Lock All' : 'Unlock All';
            }
        }
        if (lockAllBtn) {
            lockAllBtn.onclick = () => {
                const hasUnlocked = locations.some(l => !l.locked);
                locations.forEach(l => l.locked = hasUnlocked);
                saveLocations();
                forceReload();
                showTempMessage(hasUnlocked ? 'All markers LOCKED!' : 'All markers UNLOCKED!', 4000);
                playSound('click');
            };
        }

        /* DEV NOTE: VOICE SEARCH (CHROME/EDGE ONLY) */
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition && voiceSearchBtn) {
            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            voiceSearchBtn.onclick = () => {
                if (voiceSearchBtn.textContent === 'Listening...') {
                    recognition.stop();
                    voiceSearchBtn.textContent = 'Voice Search';
                    return;
                }
                if (combinedSearch) combinedSearch.value = '';
                combinedSearch.focus();
                recognition.start();
                voiceSearchBtn.textContent = 'Listening...';
                playSound('click');
            };
            recognition.onresult = e => {
                const transcript = e.results[0][0].transcript.trim();
                if (combinedSearch) combinedSearch.value = transcript;
                loadData(transcript, categoryFilter ? categoryFilter.value : '');
                voiceSearchBtn.textContent = 'Voice Search';
                showTempMessage(`Heard: "${transcript}"`, 4000);
                playSound('selectcategory');
            };
            recognition.onerror = () => {
                voiceSearchBtn.textContent = 'Voice Search';
                showTempMessage('Voice failed. Try again or type.', 3000);
                playSound('error');
            };
            recognition.onend = () => {
                voiceSearchBtn.textContent = 'Voice Search';
            };
        } else if (voiceSearchBtn) {
            voiceSearchBtn.textContent = 'Voice Search (Chrome/Edge only)';
            voiceSearchBtn.title = 'Voice Search requires Chrome or Edge';
            voiceSearchBtn.disabled = true;
            voiceSearchBtn.onclick = () => {
                showTempMessage('Voice Search only works in Chrome or Edge', 4000);
                playSound('error');
            };
        }

        /* DEV NOTE: SEARCH BAR LOGIC */
        let typingTimeout;
        let lastFilteredCount = -1;
        if (combinedSearch) {
            combinedSearch.addEventListener('input', () => {
                if (clearSearchBtn) clearSearchBtn.style.display = combinedSearch.value ? 'block' : 'none';
                const val = combinedSearch.value.trim();
                localStorage.setItem('currentSearch', val);
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => playSound('type'), 150);
                const filtered = locations.filter(loc => {
                    if (!activeCategories.has(loc.category)) return false;
                    if (categoryFilter && categoryFilter.value && loc.category !== categoryFilter.value) return false;
                    if (!val) return true;
                    return normalizeString(loc.desc + loc.category).includes(normalizeString(val));
                });
                if (lastFilteredCount !== -1 && filtered.length !== lastFilteredCount) {
                    playSound('selectcategory');
                }
                lastFilteredCount = filtered.length;
                if (!val) {
                    loadData('', categoryFilter ? categoryFilter.value : '');
                } else {
                    const gridMatch = val.toUpperCase().match(/^([A-J])(\d+)$/);
                    if (gridMatch) {
                        highlightSearchBar('grid');
                        const coords = getLatLngFromGrid(val.toUpperCase());
                        if (coords) {
                            safeFlyTo(coords.lat, coords.lng, 2);
                            showGridNotification(val.toUpperCase());
                        }
                    } else if (val.length > 0) {
                        highlightSearchBar('item');
                    }
                    loadData(val, categoryFilter ? categoryFilter.value : '');
                }
            });
        }
        if (clearSearchBtn) {
            clearSearchBtn.onclick = () => {
                if (combinedSearch) combinedSearch.value = '';
                clearSearchBtn.style.display = 'none';
                localStorage.setItem('currentSearch', '');
                loadData('', categoryFilter ? categoryFilter.value : '');
                combinedSearch.focus();
                playSound('modalClose');
            };
        }

        /* DEV NOTE: NETWORK TIMEOUT UTILITY */
        function fetchWithTimeout(url, ms = 10000) {
            return Promise.race([
                fetch(url),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))
            ]);
        }

        /* DEV NOTE: TERMS OF USE MODAL */
        const termsModal = document.createElement('div');
        termsModal.className = 'modal';
        termsModal.style.display = 'block';
        termsModal.innerHTML = `
            <div class="modal-content">
                <h2>Welcome to Fallout 76 Item Finder v${APP_VERSION}</h2>
                <p>By using this app, you agree to:</p>
                <ul>
                    <li>This app, created by MrCrazy, is for personal, non-commercial use by Fallout 76 players to track in-game items. Unauthorized copying, modification, distribution, or monetization is strictly prohibited. Do at your own risk.</li>
                    <li>Stay Updated!</li>
                    <li>Check the "Update Community Map" button periodically for the latest map version or to reset the app if you encounter issues. Find this tip in the "How to Use" section.</li>
                </ul>
                <p>Log and Track items in Appalachia with ease. Created by MrCrazy. Enjoy, and consider supporting with a <a href="https://buymeacoffee.com/mrcrazy" target="_blank" style="color:#00ff00;">Nuka-Cola</a>!</p>
                <button id="acceptTermsBtn">I Accept Terms</button>
            </div>
        `;
        const allButtons = document.querySelectorAll('button, input, select');
        function setButtonsEnabled(enabled) {
            allButtons.forEach(btn => {
                if (btn.id !== 'acceptTermsBtn') {
                    btn.disabled = !enabled;
                }
            });
        }
        if (!termsAccepted) {
            document.body.appendChild(termsModal);
            document.body.classList.add('modal-open');
            setButtonsEnabled(false);
            const acceptBtn = document.getElementById('acceptTermsBtn');
            if (acceptBtn) {
                acceptBtn.onclick = () => {
                    localStorage.setItem(TERMS_ACCEPTED_KEY, 'true');
                    termsModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    setButtonsEnabled(true);
                    playSound('click');
                };
            }
        } else {
            setButtonsEnabled(true);
        }

        /* DEV NOTE: UPDATE NOTIFICATION MODAL */
        if (localStorage.getItem(UPDATE_VERSION_KEY) !== CURRENT_UPDATE_VERSION) {
            const updateModal = document.createElement('div');
            updateModal.className = 'modal';
            updateModal.style.display = 'block';
            updateModal.innerHTML = `
                <div class="modal-content">
                    <span class="close">X</span>
                    <h2>App Updated!</h2>
                    <p><strong>Action recommended:</strong><br>
                    Export your <strong>user-created markers</strong> to keep them safe!</p>
                    <div style="margin-top:12px; text-align:center;">
                        <button id="exportUserNowBtn">Export User Markers</button>
                        <button id="gotItUpdateBtn">Got it!</button>
                    </div>
                </div>
            `;
            document.body.appendChild(updateModal);
            document.body.classList.add('modal-open');
            const closeSpan = updateModal.querySelector('.close');
            if (closeSpan) {
                closeSpan.onclick = () => {
                    updateModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    localStorage.setItem(UPDATE_VERSION_KEY, CURRENT_UPDATE_VERSION);
                };
            }
            const gotItBtn = document.getElementById('gotItUpdateBtn');
            if (gotItBtn) {
                gotItBtn.onclick = () => {
                    updateModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    localStorage.setItem(UPDATE_VERSION_KEY, CURRENT_UPDATE_VERSION);
                    playSound('click');
                };
            }
            const exportUserBtn = document.getElementById('exportUserNowBtn');
            if (exportUserBtn) {
                exportUserBtn.onclick = () => {
                    playSound('saving');
                    const userMarkers = locations.filter(loc => loc.userEdited === true);
                    if (userMarkers.length === 0) {
                        alert("No user-created markers to export yet!");
                        return;
                    }
                    const exportData = {
                        version: 1.0,
                        note: "USER-ONLY backup — safe to re-import",
                        locations: userMarkers,
                        customCategories: customCategories
                    };
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `fallout76_user_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                    showTempMessage(`Exported ${userMarkers.length} user markers!`, 4000);
                    updateModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    localStorage.setItem(UPDATE_VERSION_KEY, CURRENT_UPDATE_VERSION);
                };
            }
        }

        /* DEV NOTE: HOW TO USE BUTTON */
        if (howToUseBtn) {
            howToUseBtn.onclick = () => {
                document.getElementById('instructionsModal').style.display = 'block';
                document.body.classList.add('modal-open');
                playSound('click');
            };
        }

        /* DEV NOTE: NUKE CODES BUTTON IN TOOLS PANEL */
        if (nukeCodesBtn) {
            nukeCodesBtn.onclick = () => {
                document.getElementById('nukeCodesModal').style.display = 'block';
                document.body.classList.add('modal-open');
                playSound('click');
            };
        }

        /* DEV NOTE: RESET APP */
        if (resetAppBtn) {
            resetAppBtn.onclick = () => {
                const keepUserMarkers = confirm(
                    "WARNING: This will DELETE ALL markers, categories, and settings.\n\n" +
                    "Keep your USER-CREATED markers?\n" +
                    "OK = Save them to a backup file\n" +
                    "CANCEL = Full reset (everything lost)\n\n" +
                    "Continue?"
                );
                if (!keepUserMarkers) {
                    if (confirm("FINAL WARNING: This cannot be undone. Are you ABSOLUTELY sure?")) {
                        localStorage.clear();
                        location.reload();
                    }
                    return;
                }
                const userMarkers = locations.filter(loc => loc.userEdited === true);
                if (userMarkers.length === 0) {
                    alert("No user-created markers to save. Proceeding with full reset.");
                    if (confirm("FINAL WARNING: This cannot be undone. Are you ABSOLUTELY sure?")) {
                        localStorage.clear();
                        location.reload();
                    }
                    return;
                }
                const backupData = {
                    version: 1.0,
                    note: "User-created markers backup — safe to re-import",
                    locations: userMarkers,
                    customCategories: customCategories
                };
                const dataStr = JSON.stringify(backupData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `fallout76_user_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                link.click();
                URL.revokeObjectURL(url);
                alert(`Saved ${userMarkers.length} user markers to backup file!\n\nNow resetting app...`);
                setTimeout(() => {
                    if (confirm("FINAL WARNING: App will now reset. Continue?")) {
                        localStorage.clear();
                        location.reload();
                    }
                }, 500);
            };
        }

        /* DEV NOTE: MODAL CLOSE HANDLERS — ONLY X BUTTON */
        document.querySelectorAll('.modal .close').forEach(closeBtn => {
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeBtn.closest('.modal').style.display = 'none';
                document.body.classList.remove('modal-open');
                playSound('modalClose');
            };
        });

        /* DEV NOTE: GLOWING MARKER DETECTION */
        function isGlowing(loc) {
            return loc.addedTime && (Date.now() - loc.addedTime) < 120000;
        }

        /* DEV NOTE: MARKER ICON CREATION */
        function createMarkerIcon(loc) {
            const isTextOnly = ['named locations', 'regions'].includes(loc.category);
            if (isTextOnly) {
                const words = loc.desc.split('\n')[0].trim().split(' ');
                const shortText = words.slice(0, 3).join(' ') + (words.length > 3 ? '...' : '');
                const width = Math.min(120, Math.max(60, shortText.length * 9));
                const glowClass = isGlowing(loc) ? 'glowing' : '';
                const html = `<div class="${glowClass}" style="background:#000; color:#fff; padding:3px 6px; border:2px solid #0f0; border-radius:4px; font-weight:bold; font-size:11px; white-space:nowrap; width:${width}px; text-align:center; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(shortText)}</div>`;
                return L.divIcon({
                    className: 'text-marker',
                    html: html,
                    iconSize: [width + 12, 26],
                    iconAnchor: [(width + 12)/2, 13]
                });
            } else {
                const base = `<div class="marker-background" style="background-color:${categoryColors[loc.category] || '#808080'};">
                                <span style="font-size:18px;">${loc.icon}</span>
                              </div>`;
                return L.divIcon({
                    className: isGlowing(loc) ? 'custom-icon glowing' : 'custom-icon',
                    html: base,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
            }
        }

        /* DEV NOTE: TEMPORARY MESSAGE SYSTEM */
        const messageQueue = [];
        let activeMessageControl = null;
        function showTempMessage(html, ms = 3000) {
            messageQueue.push({ html, ms });
            if (!activeMessageControl) processMessageQueue();
        }
        function processMessageQueue() {
            if (messageQueue.length === 0 || activeMessageControl) return;
            const { html, ms } = messageQueue.shift();
            activeMessageControl = L.control({ position: 'bottomright' });
            activeMessageControl.onAdd = function() {
                const div = L.DomUtil.create('div', 'temp-message');
                div.innerHTML = html;
                div.style.background = 'rgba(0,0,0,0.85)';
                div.style.color = '#0f0';
                div.style.padding = '8px 12px';
                div.style.border = '1px solid #0f0';
                div.style.borderRadius = '6px';
                div.style.maxWidth = '300px';
                div.style.font = 'bold 13px/1.4 monospace';
                div.style.boxShadow = '0 0 10px #0f0';
                div.style.margin = '10px';
                div.style.pointerEvents = 'none';
                div.style.zIndex = '10000';
                L.DomEvent.disableClickPropagation(div);
                return div;
            };
            activeMessageControl.addTo(map);
            setTimeout(() => {
                if (activeMessageControl) {
                    map.removeControl(activeMessageControl);
                    activeMessageControl = null;
                    processMessageQueue();
                }
            }, ms);
        }

        /* DEV NOTE: POPUP EDIT FROM MARKER */
        window.editMarkerFromPopup = function(index) {
            map.closePopup();
            openModal('Edit Item', index);
        };

        /* DEV NOTE: MARKER DRAG HANDLER */
        function attachDragHandler(marker, loc) {
            let isDragging = false;
            const onDragging = (e) => {
                if (!isDragging) return;
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                const latlng = map.mouseEventToLatLng({ clientX: clientX, clientY: clientY });
                marker.setLatLng(latlng);
            };
                    const onDragEnd = () => {
            if (!isDragging) return;
            isDragging = false;
            isDraggingAny = false;
            map.dragging.enable();
            L.DomUtil.removeClass(marker._icon, 'dragging');
            L.DomEvent.off(document, 'mousemove', onDragging);
            L.DomEvent.off(document, 'mouseup', onDragEnd);
            L.DomEvent.off(document, 'touchmove', onDragging);
            L.DomEvent.off(document, 'touchend', onDragEnd);
            const newLatLng = marker.getLatLng();
            loc.lat = newLatLng.lat;
            loc.lng = newLatLng.lng;
            loc.desc = updateDescWithGrid(loc.desc, loc.lat, loc.lng);
            loc.addedTime = Date.now();
            loc.userEdited = true;
            if (loc.cid && !loc.userCid) loc.userCid = loc.cid;
            saveLocations();
            playSound('saving');
            showTempMessage(`Moved + saved! Lock to protect. ${loc.icon} ${loc.category}`, 4000);
            safeFlyTo(newLatLng.lat, newLatLng.lng, map.getZoom());
            forceReload();
        };
        const onDragStart = (e) => {
            if (loc.locked || isDraggingAny) return;
            if (e.touches) L.DomEvent.preventDefault(e);
            isDragging = true;
            isDraggingAny = true;
            map.dragging.disable();
            L.DomUtil.addClass(marker._icon, 'dragging');
            if (activeMessageControl) {
                map.removeControl(activeMessageControl);
                activeMessageControl = null;
            }
            L.DomEvent.on(document, 'mousemove', onDragging);
            L.DomEvent.on(document, 'mouseup', onDragEnd);
            L.DomEvent.on(document, 'touchmove', onDragging);
            L.DomEvent.on(document, 'touchend', onDragEnd);
        };
        marker.on('contextmenu', (e) => {
            L.DomEvent.stopPropagation(e);
            const index = locations.findIndex(l => l.id === marker.options.id);
            if (index !== -1) {
                map.closePopup();
                openModal('Edit Item', index);
                playSound('click');
            }
        });
        if (!loc.locked) {
            marker.on('dragstart', onDragStart);
        }
        marker.bindPopup(`
            <b>${loc.icon} ${loc.category.toUpperCase()}</b><br>
            <div style="max-height:80px; overflow-y:auto; margin:4px 0; padding-right:8px;">
                ${escapeHtml(loc.desc)}
            </div>
            <div style="margin:6px 0; text-align:center;">
                <span class="popup-lock-toggle" onclick="toggleLockFromPopup(${locations.indexOf(loc)})">
                    ${loc.locked ? 'LOCKED' : 'UNLOCKED'}
                </span>
            </div>
            <button onclick="editMarkerFromPopup(${locations.indexOf(loc)})"
                    style="margin-top:6px; padding:4px 10px; background:#00ff00; color:#000; border:none; border-radius:4px; cursor:pointer; font-weight:bold; font-size:12px;">
                Edit
            </button>
        `, { maxWidth: 260, autoPan: true, offset: [0, -20] });
    }

    /* DEV NOTE: ADD MARKER TO MAP */
    function addMarkerToMap(loc) {
        const marker = L.marker([loc.lat, loc.lng], {
            icon: createMarkerIcon(loc),
            id: loc.id,
            draggable: !loc.locked
        });
        attachDragHandler(marker, loc);
        const isTextOnly = ['named locations', 'regions'].includes(loc.category);
        if (clusteringEnabled && !isTextOnly) {
            clusteredMarkers.addLayer(marker);
        } else {
            nonClusteredMarkers.addLayer(marker);
        }
        if (isGlowing(loc)) {
            setTimeout(() => {
                marker.setZIndexOffset(10000);
                marker.setIcon(createMarkerIcon(loc));
            }, 100);
        }
    }

    /* DEV NOTE: COUNTER DISPLAY */
    function updateCounterDisplay() {
        const latestVersion = localStorage.getItem(MAP_VERSION_KEY) || "1.0";
        const totalFiltered = locations.filter(l => activeCategories.has(l.category)).length;
        const pageItems = locations.filter(l => activeCategories.has(l.category)).slice((tablePage - 1) * pageSize, tablePage * pageSize).length;
        if (counter) counter.innerHTML = `<strong>Map Version ${latestVersion}</strong> - <strong>${totalFiltered}</strong> logged locations - <strong>${pageItems}</strong> showing.`;
    }

    /* DEV NOTE: TABLE REFRESH */
    function refreshTable(search = '', catFilter = '') {
        const tbody = document.querySelector('#locationsTable tbody');
        if (!tbody) return;
        tbody.innerHTML = '';
        const filtered = locations.filter(loc => {
            if (!activeCategories.has(loc.category)) return false;
            if (catFilter && loc.category !== catFilter) return false;
            if (!search) return true;
            return normalizeString(loc.desc).includes(normalizeString(search)) ||
                   normalizeString(loc.category).includes(normalizeString(search));
        });
        const glowing = filtered.filter(isGlowing).sort((a, b) => b.addedTime - a.addedTime);
        const normal = filtered.filter(loc => !isGlowing(loc)).sort((a, b) => {
            const catDiff = a.category.localeCompare(b.category);
            return catDiff !== 0 ? catDiff : a.desc.localeCompare(b.desc);
        });
        const sorted = [...glowing, ...normal];
        const start = (tablePage - 1) * pageSize;
        const pageItems = sorted.slice(start, start + pageSize);
        pageItems.forEach(loc => {
            const tr = document.createElement('tr');
            if (isGlowing(loc)) tr.classList.add('glowing');
            const shortDesc = loc.desc.split('\n')[0].trim();
            const lockEmoji = loc.locked ? 'LOCKED' : 'UNLOCKED';
            const lockCell = `<td><span class="lock-toggle" onclick="toggleLockFromTable(${locations.indexOf(loc)})" title="${loc.locked ? 'Locked' : 'Unlocked'}">${lockEmoji}</span></td>`;
            const iconCell = ['named locations', 'regions'].includes(loc.category)
                ? `<td><div class="text-location">${escapeHtml(shortDesc)}</div></td>`
                : `<td><div class="icon-circle" style="background-color:${categoryColors[loc.category] || '#808080'};">${loc.icon}</div></td>`;
            const catCell = `<td>${escapeHtml(loc.category)} ${loc.icon}</td>`;
            const descCell = `<td>${escapeHtml(shortDesc)}</td>`;
            tr.innerHTML = lockCell + iconCell + catCell + descCell;
            tr.onclick = (e) => {
                if (e.target.tagName === 'SPAN') return;
                e.preventDefault();
                const mapEl = document.getElementById('map');
                if (mapEl) mapEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Smart delay based on current zoom
                const currentZoom = map.getZoom();
                const targetZoom = 4;
                const zoomDiff = Math.abs(targetZoom - currentZoom);
                const delay = 400 + (zoomDiff * 200); // 200ms per zoom level

                setTimeout(() => {
                    safeFlyTo(loc.lat, loc.lng, targetZoom);
                    setTimeout(() => {
                        const allMarkers = [...clusteredMarkers.getLayers(), ...nonClusteredMarkers.getLayers()];
                        const marker = allMarkers.find(m => m.options.id === loc.id);
                        if (marker) {
                            marker.openPopup();
                            const popup = marker.getPopup();
                            if (popup) {
                                popup.options.offset = [0, -20];
                                popup.update();
                            }
                        }
                        playSound('click');
                    }, 1000); // Wait for flyTo to settle
                }, delay);
            };
            tr.oncontextmenu = (e) => {
                e.preventDefault();
                const mapEl = document.getElementById('map');
                if (mapEl) mapEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                setTimeout(() => {
                    safeFlyTo(loc.lat, loc.lng, 4);
                    openModal('Edit Item', locations.findIndex(l => l.id === loc.id));
                }, 600);
            };
            tbody.appendChild(tr);
        });
        const totalPages = Math.ceil(sorted.length / pageSize);
        tablePage = Math.min(tablePage, totalPages || 1);
        if (pageInfo) pageInfo.textContent = `Page ${tablePage} of ${totalPages || 1}`;
        if (prevPageBtn) prevPageBtn.disabled = tablePage <= 1;
        if (nextPageBtn) nextPageBtn.disabled = tablePage >= totalPages;
        updateCounterDisplay();
    }

    /* DEV NOTE: LOCK TOGGLE FROM TABLE */
    window.toggleLockFromTable = function(index) {
        const loc = locations[index];
        loc.locked = !loc.locked;
        saveLocations();
        forceReload();
        showTempMessage(loc.locked ? 'Marker locked — unlock to edit!' : 'Marker unlocked!', 4000);
        playSound('click');
    };

    /* DEV NOTE: LOCK TOGGLE FROM POPUP */
    window.toggleLockFromPopup = function(index) {
        const loc = locations[index];
        loc.locked = !loc.locked;
        saveLocations();
        forceReload();
        map.closePopup();
        showTempMessage(loc.locked ? 'Locked!' : 'Unlocked!', 3000);
        playSound('click');
    };

    /* DEV NOTE: GLOWING MARKER UPDATE LOOP */
    setInterval(() => {
        if (document.visibilityState === 'visible') {
            [clusteredMarkers, nonClusteredMarkers].forEach(group => {
                group.eachLayer(marker => {
                    const loc = locations.find(l => l.id === marker.options.id);
                    if (loc) {
                        const shouldGlow = isGlowing(loc);
                        const currentIcon = marker.getIcon();
                        if (shouldGlow && !currentIcon.options.className.includes('glowing')) {
                            marker.setIcon(createMarkerIcon(loc));
                            marker.setZIndexOffset(10000);
                        } else if (!shouldGlow && currentIcon.options.className.includes('glowing')) {
                            marker.setIcon(createMarkerIcon(loc));
                            marker.setZIndexOffset(0);
                        }
                        if (loc.locked) {
                            marker.dragging?.disable();
                        } else {
                            marker.dragging?.enable();
                        }
                    }
                });
            });
            refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
            updateLockAllBtn();
        }
    }, 1000);

    /* DEV NOTE: RENDER CATEGORY TOGGLES */
    function renderCategoryToggles() {
        const container = document.getElementById('categoryCheckboxes');
        if (!container) return;
        container.innerHTML = '';
        const allCats = [...Object.keys(defaultCategoryIcons), ...Object.keys(customCategories)].sort();
        allCats.forEach(cat => {
            const label = document.createElement('label');
            const checked = activeCategories.has(cat) ? 'checked' : '';
            label.innerHTML = `<input type="checkbox" value="${cat}" ${checked}><span>${cat} ${categoryIcons[cat] || ''}</span>`;
            container.appendChild(label);
        });
        container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', () => {
                const val = cb.value;
                if (cb.checked) activeCategories.add(val);
                else activeCategories.delete(val);
                localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                loadData(combinedSearch.value, categoryFilter.value);
                playSound('selectcategory');
            });
        });
    }

    /* DEV NOTE: UPDATE CATEGORY DROPDOWNS */
    function updateCategoryDropdowns() {
        const categories = [...Object.keys(defaultCategoryIcons), ...Object.keys(customCategories)].sort();
        const makeOption = cat => `<option value="${cat}">${cat} ${categoryIcons[cat] || ''}</option>`;
        if (categoryFilter) categoryFilter.innerHTML = '<option value="">All Categories</option>' + categories.map(makeOption).join('');
        if (itemCategorySelect) itemCategorySelect.innerHTML = categories.map(makeOption).join('');
        if (currentCategoryFilter && categories.includes(currentCategoryFilter) && categoryFilter) {
            categoryFilter.value = currentCategoryFilter;
        }
    }

    /* DEV NOTE: MODAL OPEN */
    function openModal(title, index = -1, isDupe = false) {
        if (!modalTitle) return;
        modalTitle.innerHTML = `${title} <span id="modalLockToggle" style="font-size:22px; cursor:pointer; margin-left:10px;">${index >= 0 ? (locations[index].locked ? 'LOCKED' : 'UNLOCKED') : 'LOCKED'}</span>`;
        currentIndex = index;
        document.getElementById('saveItemBtn').style.display = 'inline-block';
        const lockToggle = document.getElementById('modalLockToggle');
        if (index >= 0 && !isDupe) {
            const loc = locations[index];
            if (itemCategorySelect) itemCategorySelect.value = loc.category || 'misc';
            if (itemDescInput) itemDescInput.value = loc.desc || '';
            if (itemCategorySelect) itemCategorySelect.disabled = loc.locked;
            if (itemDescInput) itemDescInput.disabled = loc.locked;
            if (deleteBtn) deleteBtn.style.display = loc.locked ? 'none' : 'inline-block';
            if (duplicateBtn) duplicateBtn.style.display = loc.locked ? 'none' : 'inline-block';
            if (undoBtn) undoBtn.style.display = lastDeleted ? 'inline-block' : 'none';
            if (shareItemBtn) shareItemBtn.style.display = 'inline-block';
            if (lockToggle) {
                lockToggle.onclick = () => {
                    loc.locked = !loc.locked;
                    lockToggle.textContent = loc.locked ? 'LOCKED' : 'UNLOCKED';
                    if (itemCategorySelect) itemCategorySelect.disabled = loc.locked;
                    if (itemDescInput) itemDescInput.disabled = loc.locked;
                    if (deleteBtn) deleteBtn.style.display = loc.locked ? 'none' : 'inline-block';
                    if (duplicateBtn) duplicateBtn.style.display = loc.locked ? 'none' : 'inline-block';
                    saveLocations();
                    forceReload();
                    showTempMessage(loc.locked ? 'Marker locked — unlock to edit!' : 'Marker unlocked!', 4000);
                    playSound('click');
                };
            }
        } else {
            if (itemCategorySelect) itemCategorySelect.value = 'misc';
            if (itemDescInput) itemDescInput.value = '';
            if (itemCategorySelect) itemCategorySelect.disabled = false;
            if (itemDescInput) itemDescInput.disabled = false;
            if (deleteBtn) deleteBtn.style.display = 'none';
            if (duplicateBtn) duplicateBtn.style.display = 'none';
            if (undoBtn) undoBtn.style.display = 'none';
            if (shareItemBtn) shareItemBtn.style.display = 'none';
            if (lockToggle) {
                lockToggle.onclick = null;
                lockToggle.style.cursor = 'default';
            }
        }
        if (itemModal) itemModal.style.display = 'block';
        document.body.classList.add('modal-open');
        playSound('click');
    }

    /* DEV NOTE: MODAL CLOSE */
    function closeModal(modal) {
        if (modal) modal.style.display = 'none';
        document.body.classList.remove('modal-open');
        playSound('modalClose');
    }

    /* DEV NOTE: XP SYSTEM */
    function recalculateXP() {
        xp = locations.length * xpPerMarker;
        level = 1 + Math.floor(xp / xpPerLevel);
        xp = xp % xpPerLevel;
        if (xp < 0) xp = 0;
        localStorage.setItem('fo76_level', level);
        localStorage.setItem('fo76_xp', xp);
    }
    recalculateXP();

    function updateXPBar() {
        if (levelSpan) levelSpan.textContent = level;
        if (xpProgress) {
            xpProgress.value = xp;
            xpProgress.max = xpPerLevel;
        }
        if (xpText) xpText.textContent = `${xp} / ${xpPerLevel}`;
    }

    /* DEV NOTE: MAIN DATA LOADER */
    function loadData(search = '', catFilter = '') {
        clusteredMarkers.clearLayers();
        nonClusteredMarkers.clearLayers();
        const filtered = locations.filter(loc => activeCategories.has(loc.category) && (!catFilter || loc.category === catFilter) && (!search || normalizeString(loc.desc + loc.category).includes(normalizeString(search))));
        filtered.forEach(addMarkerToMap);
        refreshTable(search, catFilter);
        updateXPBar();
        drawGrid();
        saveAppState();
        updateLockAllBtn();
    }

    /* DEV NOTE: FORCE RELOAD */
    function forceReload() {
        saveAppState();
        loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
        renderCategoryToggles();
        updateCategoryDropdowns();
    }

    /* DEV NOTE: SAVE APP STATE */
    function saveAppState() {
        localStorage.setItem('currentSearch', combinedSearch ? combinedSearch.value : '');
        localStorage.setItem('currentCategoryFilter', categoryFilter ? categoryFilter.value : '');
        localStorage.setItem('tablePage', tablePage);
        localStorage.setItem('clusteringEnabled', clusteringEnabled);
        localStorage.setItem('gridEnabled', gridEnabled);
        localStorage.setItem('currentMap', currentMap);
        localStorage.setItem(MAP_VERSION_KEY, communityVersion);
        localStorage.setItem('titleVisible', titleVisible);
        localStorage.setItem('toolsVisible', toolsVisible);
    }

    /* DEV NOTE: SAVE LOCATIONS */
    function saveLocations() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(locations));
        saveAppState();
    }

    /* DEV NOTE: STRING UTILITIES */
    function normalizeString(s) { return (s || '').toString().trim().toLowerCase(); }
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe.toString()
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    /* DEV NOTE: SAFE MAP FLY */
    let flyTimeout;
    function safeFlyTo(lat, lng, zoom = 2) {
        if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) return;
        if (lat < 0 || lat > 4096 || lng < 0 || lng > 4096) return;
        clearTimeout(flyTimeout);
        flyTimeout = setTimeout(() => {
            map.flyTo([lat, lng], zoom, { duration: 0.8 });
        }, 100);
    }

    /* DEV NOTE: EXPORT MARKERS */
    if (exportBtn) {
        exportBtn.onclick = () => {
            playSound('saving');
            const wantsAll = confirm('Click **OK** to export **ALL** locations + custom categories.\n\nClick **Cancel** to export **USER-LOGGED** locations only.');
            const exportData = {
                version: 1.0,
                communityVersion: communityVersion,
                customCategories: customCategories
            };
            let exportedCount = 0;
            if (wantsAll) {
                exportData.locations = locations;
                exportData.note = 'ALL logged locations (community + user)';
                exportedCount = locations.length;
            } else {
                exportData.locations = locations.filter(loc => loc.userEdited === true);
                exportData.note = 'USER-ONLY locations (your edits only)';
                exportedCount = exportData.locations.length;
            }
            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const typeSuffix = wantsAll ? 'all' : 'user';
            link.download = `fallout76_${typeSuffix}_${exportData.locations.length}_locations_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            link.click();
            URL.revokeObjectURL(url);
            let report = wantsAll ? 'Exported **ALL** locations!' : 'Exported **USER-ONLY** locations!';
            report += `\n\n• ${exportedCount} markers\n`;
            report += `• ${Object.keys(customCategories).length} custom categories\n`;
            report += `• Community version: ${communityVersion}`;
            alert(report);
        };
    }

    /* DEV NOTE: IMPORT MARKERS */
    if (importBtn) {
        importBtn.onclick = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = e => {
                const file = e.target?.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = ev => {
                    backupBeforeImport();
                    try {
                        const data = JSON.parse(ev.target.result);
                        const incoming = data.locations || [];
                        const existingByCid = new Map();
                        const existingByKey = new Map();
                        const userEditedCids = new Set();
                        const userEditedKeys = new Set();
                        locations.forEach(l => {
                            if (l.cid) {
                                existingByCid.set(l.cid, l);
                                if (l.userEdited) userEditedCids.add(l.cid);
                            } else {
                                const key = `${l.desc}|${Math.round(l.lat)}|${Math.round(l.lng)}`;
                                existingByKey.set(key, l);
                                if (l.userEdited) userEditedKeys.add(key);
                            }
                        });
                        const seenCids = new Set();
                        for (const imp of incoming) {
                            if (imp.cid && seenCids.has(imp.cid)) {
                                console.warn(`Skipping duplicate CID "${imp.cid}" in import file`);
                                continue;
                            }
                            if (imp.cid) seenCids.add(imp.cid);
                        }
                        const preserveEdits = confirm(
                            `IMPORT OPTIONS:\n\n` +
                            `• OK = PRESERVE your edits/moves\n` +
                            `• CANCEL = RESET ALL community markers to original\n\n` +
                            `Choose wisely.`
                        );
                        const toAdd = [];
                        const toReplace = [];
                        let skippedUserEdited = 0;
                        let resetCount = 0;
                        let addedCount = 0;
                        let updatedCount = 0;
                        let movedCount = 0;
                        let descChangedCount = 0;
                        let catChangedCount = 0;
                        incoming.forEach(imp => {
                            if (seenCids.has(imp.cid) && incoming.filter(i => i.cid === imp.cid).length > 1) {
                                return;
                            }
                            const newId = generateUniqueId();
                            const candidate = { ...imp, id: newId, addedTime: Date.now(), locked: true }; // AUTO-LOCK
                            if (imp.cid) {
                                const existing = existingByCid.get(imp.cid);
                                if (!preserveEdits) {
                                    if (existing) {
                                        candidate.id = existing.id;
                                        toReplace.push(candidate);
                                        resetCount++;
                                        updatedCount++;
                                        if (Math.abs(existing.lat - imp.lat) > 1 || Math.abs(existing.lng - imp.lng) > 1) movedCount++;
                                        if (existing.desc !== imp.desc) descChangedCount++;
                                        if (existing.category !== imp.category) catChangedCount++;
                                    } else {
                                        candidate.userEdited = false;
                                        toAdd.push(candidate);
                                        addedCount++;
                                    }
                                    return;
                                }
                                if (existing && userEditedCids.has(imp.cid)) {
                                    existing.category = imp.category || existing.category;
                                    existing.icon = imp.icon || existing.icon;
                                    existing.addedTime = Date.now();
                                    existing.locked = true;
                                    skippedUserEdited++;
                                    return;
                                }
                                if (existing) {
                                    candidate.id = existing.id;
                                    toReplace.push(candidate);
                                    updatedCount++;
                                    if (Math.abs(existing.lat - imp.lat) > 1 || Math.abs(existing.lng - imp.lng) > 1) movedCount++;
                                    if (existing.desc !== imp.desc) descChangedCount++;
                                    if (existing.category !== imp.category) catChangedCount++;
                                } else {
                                    candidate.userEdited = false;
                                    toAdd.push(candidate);
                                    addedCount++;
                                }
                                return;
                            }
                            const fallbackKey = `${imp.desc}|${Math.round(imp.lat)}|${Math.round(imp.lng)}`;
                            const existingFallback = existingByKey.get(fallbackKey);
                            if (!preserveEdits) {
                                if (existingFallback) {
                                    candidate.id = existingFallback.id;
                                    toReplace.push(candidate);
                                    resetCount++;
                                    updatedCount++;
                                    if (Math.abs(existingFallback.lat - imp.lat) > 1 || Math.abs(existingFallback.lng - imp.lng) > 1) movedCount++;
                                    if (existingFallback.desc !== imp.desc) descChangedCount++;
                                    if (existingFallback.category !== imp.category) catChangedCount++;
                                } else {
                                    candidate.userEdited = true;
                                    toAdd.push(candidate);
                                    addedCount++;
                                }
                                return;
                            }
                            if (existingFallback && userEditedKeys.has(fallbackKey)) {
                                existingFallback.category = imp.category || existingFallback.category;
                                existingFallback.icon = imp.icon || existingFallback.icon;
                                existingFallback.addedTime = Date.now();
                                existingFallback.locked = true;
                                skippedUserEdited++;
                                return;
                            }
                            if (existingFallback) {
                                candidate.id = existingFallback.id;
                                toReplace.push(candidate);
                                updatedCount++;
                                if (Math.abs(existingFallback.lat - imp.lat) > 1 || Math.abs(existingFallback.lng - imp.lng) > 1) movedCount++;
                                if (existingFallback.desc !== imp.desc) descChangedCount++;
                                if (existingFallback.category !== imp.category) catChangedCount++;
                            } else {
                                candidate.userEdited = true;
                                toAdd.push(candidate);
                                addedCount++;
                            }
                        });
                        const replaceIds = toReplace.map(r => r.id);
                        locations = locations.filter(l => !replaceIds.includes(l.id));
                        locations = [...locations, ...toAdd, ...toReplace];
                        let newCats = 0;
                        if (data.customCategories && typeof data.customCategories === 'object') {
                            Object.entries(data.customCategories).forEach(([name, emoji]) => {
                                if (!customCategories[name] && !defaultCategoryIcons[name] && isValidEmoji(emoji)) {
                                    customCategories[name] = emoji;
                                    categoryIcons[name] = emoji;
                                    categoryColors[name] = '#f0e68c';
                                    activeCategories.add(name);
                                    newCats++;
                                }
                            });
                        }
                        communityVersion = data.communityVersion || communityVersion;
                        localStorage.setItem(MAP_VERSION_KEY, communityVersion);
                        localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                        localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                        recalculateXP();
                        saveLocations();
                        setTimeout(() => {
                            forceReload();
                            updateCounterDisplay();
                        }, 100);
                        let report = `Imported ${incoming.length} markers from file!\n\n`;
                        if (addedCount) report += `+ ${addedCount} new markers added\n`;
                        if (updatedCount) report += `Updated ${updatedCount} markers updated\n`;
                        if (movedCount) report += ` • ${movedCount} moved\n`;
                        if (descChangedCount) report += ` • ${descChangedCount} description changes\n`;
                        if (catChangedCount) report += ` • ${catChangedCount} category changes\n`;
                        if (resetCount) report += `Reset ${resetCount} community markers reset\n`;
                        if (skippedUserEdited) report += `Preserved ${skippedUserEdited} user edits preserved\n`;
                        if (newCats) report += `New ${newCats} new custom categories\n`;
                        report += `\nTotal locations: ${locations.length}\n`;
                        report += `Community version: ${communityVersion}`;
                        alert(report);
                        playSound('saving');
                    } catch (err) {
                        console.error('Import error:', err);
                        alert(`Error: ${err.message || 'Invalid JSON'}`);
                        playSound('error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        };
    }

    /* DEV NOTE: COMMUNITY MAP UPDATE */
    if (downloadCommunityBtn) {
        downloadCommunityBtn.onclick = () => {
            playSound('click');
            if (!confirm(
                `UPDATE COMMUNITY MAP?\n\n` +
                `• Adds new locations\n` +
                `• Updates moved/changed community markers\n` +
                `• YOUR edits & personal markers are 100% SAFE\n\n` +
                `Continue?`
            )) return;
            downloadCommunityBtn.disabled = true;
            downloadCommunityBtn.textContent = 'Updating...';
            const url = `https://raw.githubusercontent.com/0mrcrazy0/fallout76-itemfindermap-beta/main/communitymap.json`;
            fetchWithTimeout(url)
                .then(r => {
                    if (!r.ok) throw new Error(`HTTP ${r.status}`);
                    return r.text();
                })
                .then(text => {
                    backupBeforeImport();
                    try {
                        const data = JSON.parse(text);
                        const incoming = data.locations || [];
                        const existingByCid = new Map();
                        const existingByKey = new Map();
                        const userEditedCids = new Set();
                        const userEditedKeys = new Set();
                        locations.forEach(l => {
                            if (l.cid) {
                                existingByCid.set(l.cid, l);
                                if (l.userEdited) userEditedCids.add(l.cid);
                            } else {
                                const key = `${l.desc}|${Math.round(l.lat)}|${Math.round(l.lng)}`;
                                existingByKey.set(key, l);
                                if (l.userEdited) userEditedKeys.add(key);
                            }
                        });
                        const seenCids = new Set();
                        for (const imp of incoming) {
                            if (imp.cid && seenCids.has(imp.cid)) {
                                console.warn(`Skipping duplicate CID "${imp.cid}" in community update`);
                                continue;
                            }
                            if (imp.cid) seenCids.add(imp.cid);
                        }
                        const preserveEdits = true;
                        const toAdd = [];
                        const toReplace = [];
                        let skippedUserEdited = 0;
                        let addedCount = 0;
                        let updatedCount = 0;
                        let movedCount = 0;
                        let descChangedCount = 0;
                        let catChangedCount = 0;
                        incoming.forEach(imp => {
                            if (seenCids.has(imp.cid) && incoming.filter(i => i.cid === imp.cid).length > 1) {
                                return;
                            }
                            const newId = generateUniqueId();
                            const candidate = { ...imp, id: newId, addedTime: Date.now(), locked: true }; // AUTO-LOCK
                            if (imp.cid) {
                                const existing = existingByCid.get(imp.cid);
                                if (existing && userEditedCids.has(imp.cid)) {
                                    existing.category = imp.category || existing.category;
                                    existing.icon = imp.icon || existing.icon;
                                    existing.addedTime = Date.now();
                                    existing.locked = true;
                                    skippedUserEdited++;
                                    return;
                                }
                                if (existing) {
                                    candidate.id = existing.id;
                                    toReplace.push(candidate);
                                    updatedCount++;
                                    if (Math.abs(existing.lat - imp.lat) > 1 || Math.abs(existing.lng - imp.lng) > 1) movedCount++;
                                    if (existing.desc !== imp.desc) descChangedCount++;
                                    if (existing.category !== imp.category) catChangedCount++;
                                } else {
                                    candidate.userEdited = false;
                                    toAdd.push(candidate);
                                    addedCount++;
                                }
                                return;
                            }
                            const fallbackKey = `${imp.desc}|${Math.round(imp.lat)}|${Math.round(imp.lng)}`;
                            const existingFallback = existingByKey.get(fallbackKey);
                            if (existingFallback && userEditedKeys.has(fallbackKey)) {
                                existingFallback.category = imp.category || existingFallback.category;
                                existingFallback.icon = imp.icon || existingFallback.icon;
                                existingFallback.addedTime = Date.now();
                                existingFallback.locked = true;
                                skippedUserEdited++;
                                return;
                            }
                            if (existingFallback) {
                                candidate.id = existingFallback.id;
                                toReplace.push(candidate);
                                updatedCount++;
                                if (Math.abs(existingFallback.lat - imp.lat) > 1 || Math.abs(existingFallback.lng - imp.lng) > 1) movedCount++;
                                if (existingFallback.desc !== imp.desc) descChangedCount++;
                                if (existingFallback.category !== imp.category) catChangedCount++;
                            } else {
                                candidate.userEdited = true;
                                toAdd.push(candidate);
                                addedCount++;
                            }
                        });
                        const replaceIds = toReplace.map(r => r.id);
                        locations = locations.filter(l => !replaceIds.includes(l.id));
                        locations = [...locations, ...toAdd, ...toReplace];
                        let newCats = 0;
                        if (data.customCategories && typeof data.customCategories === 'object') {
                            Object.entries(data.customCategories).forEach(([name, emoji]) => {
                                if (!customCategories[name] && !defaultCategoryIcons[name] && isValidEmoji(emoji)) {
                                    customCategories[name] = emoji;
                                    categoryIcons[name] = emoji;
                                    categoryColors[name] = '#f0e68c';
                                    activeCategories.add(name);
                                    newCats++;
                                }
                            });
                        }
                        communityVersion = data.communityVersion || communityVersion;
                        localStorage.setItem(MAP_VERSION_KEY, communityVersion);
                        localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                        localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                        recalculateXP();
                        saveLocations();
                        setTimeout(() => {
                            forceReload();
                            updateCounterDisplay();
                        }, 100);
                        let report = `Community Map Updated!\nVersion: ${communityVersion}\n\n`;
                        if (addedCount) report += `+ ${addedCount} new markers added\n`;
                        if (updatedCount) report += `Updated ${updatedCount} markers updated\n`;
                        if (movedCount) report += ` • ${movedCount} moved\n`;
                        if (descChangedCount) report += ` • ${descChangedCount} description changes\n`;
                        if (catChangedCount) report += ` • ${catChangedCount} category changes\n`;
                        if (skippedUserEdited) report += `Preserved ${skippedUserEdited} user edits preserved\n`;
                        report += `\nTotal locations: ${locations.length}`;
                        alert(report);
                        playSound('saving');
                    } catch (err) {
                        console.error('Community update error:', err);
                        alert(`Update failed: ${err.message}`);
                        playSound('error');
                    }
                })
                .catch(err => {
                    alert(`Update failed: ${err.message}\n\nCheck internet or file.`);
                    playSound('error');
                })
                .finally(() => {
                    if (downloadCommunityBtn) {
                        downloadCommunityBtn.disabled = false;
                        downloadCommunityBtn.textContent = 'Update Community Map';
                    }
                });
        };
    }

    /* DEV NOTE: IMPORT BACKUP & UNDO */
    function backupBeforeImport() {
        lastImportBackup = {
            locations: JSON.parse(JSON.stringify(locations)),
            customCategories: { ...customCategories },
            communityVersion: communityVersion,
            activeCategories: new Set(activeCategories)
        };
        if (undoImportBtn) undoImportBtn.style.display = 'inline-block';
        showTempMessage('Import backup saved. Use "Undo Import" if needed.', 4000);
    }

    function undoLastImport() {
        if (!lastImportBackup) {
            alert("No import to undo.");
            return;
        }
        if (!confirm("Undo last import? This will restore your previous state.")) return;
        locations = lastImportBackup.locations;
        customCategories = lastImportBackup.customCategories;
        communityVersion = lastImportBackup.communityVersion;
        activeCategories = lastImportBackup.activeCategories;
        localStorage.setItem(STORAGE_KEY, JSON.stringify(locations));
        localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
        localStorage.setItem(MAP_VERSION_KEY, communityVersion);
        localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
        lastImportBackup = null;
        if (undoImportBtn) undoImportBtn.style.display = 'none';
        recalculateXP();
        forceReload();
        updateCounterDisplay();
        showTempMessage('Import undone! Previous state restored.', 4000);
        playSound('undo');
    }
    if (undoImportBtn) undoImportBtn.onclick = undoLastImport;

    /* DEV NOTE: SAVE MAP AS JPEG */
    if (saveJpegBtn) {
        saveJpegBtn.onclick = () => {
            playSound('saving');
            html2canvas(document.getElementById('map'), { useCORS: true, scale: 2 }).then(canvas => {
                const link = document.createElement('a');
                link.download = `fallout76_map_${new Date().toISOString().replace(/[:.]/g, '-')}.jpg`;
                link.href = canvas.toDataURL('image/jpeg', 0.9);
                link.click();
                alert('Map saved as JPEG. Check your downloads folder!');
            }).catch(err => {
                console.error(err);
                alert('Failed to save map as JPEG.');
                playSound('error');
            });
        };
    }

    /* DEV NOTE: PAGINATION */
    if (prevPageBtn) {
        prevPageBtn.onclick = () => {
            if (tablePage > 1) {
                tablePage--;
                localStorage.setItem('tablePage', tablePage);
                refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                playSound('click');
            }
        };
    }
    if (nextPageBtn) {
        nextPageBtn.onclick = () => {
            const total = Math.ceil(locations.filter(l => activeCategories.has(l.category)).length / pageSize);
            if (tablePage < total) {
                tablePage++;
                localStorage.setItem('tablePage', tablePage);
                refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                playSound('click');
            }
        };
    }

    /* DEV NOTE: TOOL BUTTONS */
    toggleSoundsBtn.onclick = () => {
        soundsEnabled = !soundsEnabled;
        localStorage.setItem('soundsEnabled', soundsEnabled);
        toggleSoundsBtn.textContent = soundsEnabled ? 'Sounds: On' : 'Sounds: Off';
        playSound('click');
    };

    toggleClusterBtn.onclick = () => {
        clusteringEnabled = !clusteringEnabled;
        localStorage.setItem('clusteringEnabled', clusteringEnabled);
        toggleClusterBtn.textContent = `Clustering: ${clusteringEnabled ? 'On' : 'Off'}`;
        playSound('click');
        loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
    };

    toggleMapBtn.onclick = () => {
        currentMap = currentMap === 'named' ? 'noName' : 'named';
        localStorage.setItem('currentMap', currentMap);
        toggleMapBtn.textContent = currentMap === 'named' ? 'Show No-Name Map' : 'Show Named Map';
        map.removeLayer(imageOverlay);
        imageOverlay = L.imageOverlay(mapUrls[currentMap], imageBounds).addTo(map);
        playSound('saving');
    };

    toggleGridBtn.onclick = () => {
        gridEnabled = !gridEnabled;
        localStorage.setItem('gridEnabled', gridEnabled);
        toggleGridBtn.textContent = `Grid: ${gridEnabled ? 'On' : 'Off'}`;
        drawGrid();
        if (gridEnabled) {
            map.getContainer().classList.add('hover-coords');
        } else {
            map.getContainer().classList.remove('hover-coords');
            if (coordHoverControl) coordHoverControl.getContainer().classList.remove('show');
        }
        playSound('click');
    };

    toggleCategoryModalBtn.onclick = () => {
        if (categoryToggleModal) categoryToggleModal.style.display = 'block';
        document.body.classList.add('modal-open');
        renderCategoryToggles();
        playSound('selectcategory');
    };

    const selectAllBtn = document.getElementById('selectAllBtn');
    if (selectAllBtn) {
        selectAllBtn.onclick = () => {
            activeCategories = new Set(Object.keys(categoryIcons));
            localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
            renderCategoryToggles();
            loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
            playSound('click');
        };
    }
    const deselectAllBtn = document.getElementById('deselectAllBtn');
    if (deselectAllBtn) {
        deselectAllBtn.onclick = () => {
            activeCategories = new Set();
            localStorage.setItem('activeCategories', JSON.stringify([]));
            renderCategoryToggles();
            loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
            playSound('click');
        };
    }
    const createCategoryBtn = document.getElementById('createCategoryBtn');
    if (createCategoryBtn) {
        createCategoryBtn.onclick = () => {
            const newName = document.getElementById('newCategoryName');
            const newEmoji = document.getElementById('newCategoryEmoji');
            if (newName) newName.value = '';
            if (newEmoji) newEmoji.value = '';
            const createModal = document.getElementById('createCategoryModal');
            if (createModal) createModal.style.display = 'block';
            playSound('click');
        };
    }
    const deleteCategoryBtn = document.getElementById('deleteCategoryBtn');
    if (deleteCategoryBtn) {
        deleteCategoryBtn.onclick = () => {
            const select = document.getElementById('deleteCategorySelect');
            if (select) {
                select.innerHTML = '<option value="">Select a custom category</option>';
                Object.keys(customCategories).sort().forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = `${name} ${customCategories[name]}`;
                    select.appendChild(opt);
                });
            }
            const deleteModal = document.getElementById('deleteCategoryModal');
            if (deleteModal) deleteModal.style.display = 'block';
            playSound('click');
        };
    }
    const confirmDeleteCategoryBtn = document.getElementById('confirmDeleteCategoryBtn');
    if (confirmDeleteCategoryBtn) {
        confirmDeleteCategoryBtn.onclick = () => {
            const select = document.getElementById('deleteCategorySelect');
            const name = select ? select.value : '';
            if (!name || !customCategories[name]) return;
            if (confirm(`Delete category "${name}"? All markers will be reassigned to "misc".`)) {
                locations.forEach(loc => {
                    if (loc.category === name) loc.category = 'misc';
                });
                delete customCategories[name];
                delete categoryIcons[name];
                delete categoryColors[name];
                activeCategories.delete(name);
                localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                saveLocations();
                forceReload();
                const deleteModal = document.getElementById('deleteCategoryModal');
                if (deleteModal) deleteModal.style.display = 'none';
                playSound('delete');
            }
        };
    }
    const closeCategoryToggleBtn = document.getElementById('closeCategoryToggleBtn');
    if (closeCategoryToggleBtn) {
        closeCategoryToggleBtn.onclick = () => {
            closeModal(categoryToggleModal);
        };
    }
    document.querySelectorAll('#createCategoryModal .close, #deleteCategoryModal .close').forEach(closeBtn => {
        closeBtn.onclick = () => closeModal(closeBtn.closest('.modal'));
    });

    /* DEV NOTE: SAVE ITEM */
    const saveItemBtn = document.getElementById('saveItemBtn');
    if (saveItemBtn) {
        saveItemBtn.onclick = () => {
            const category = itemCategorySelect ? itemCategorySelect.value : 'misc';
            let desc = itemDescInput ? itemDescInput.value.trim() : '';
            if (!desc) {
                const lat = currentIndex >= 0 ? locations[currentIndex].lat : tempLatLng.lat;
                const lng = currentIndex >= 0 ? locations[currentIndex].lng : tempLatLng.lng;
                const grid = getGridFromLatLng(lat, lng);
                const x = Math.round(lng);
                const y = Math.round(lat);
                desc = grid ? `Grid ${grid} (X: ${x}, Y: ${y})` : `X: ${x}, Y: ${y}`;
                if (itemDescInput) itemDescInput.value = desc;
            }
            if (!desc) return;
            const wasNewLog = currentIndex < 0;
            if (currentIndex >= 0) {
                const loc = locations[currentIndex];
                if (loc.locked) {
                    showTempMessage('Marker locked — unlock to edit!', 4000);
                    playSound('error');
                    return;
                }
                loc.category = category;
                loc.desc = desc;
                loc.icon = categoryIcons[category] || 'UNKNOWN';
                loc.addedTime = Date.now();
                loc.userEdited = true;
            } else {
                const newLoc = createNewLocation(tempLatLng.lat, tempLatLng.lng, category, desc);
                locations.push(newLoc);
                recalculateXP();
            }
            closeModal(itemModal);
            saveLocations();
            playSound('saving');
            showTempMessage('Saved! New marker is LOCKED by default.', 4000);
            const finalLoc = currentIndex >= 0 ? locations[currentIndex] : locations[locations.length - 1];
            safeFlyTo(finalLoc.lat, finalLoc.lng, map.getZoom());
            forceReload();
            if (wasNewLog && categoryFilter) categoryFilter.value = '';
            setTimeout(() => { isDraggingAny = false; }, 600);
        };
    }

    /* DEV NOTE: DELETE & UNDO */
    if (deleteBtn) {
        deleteBtn.onclick = () => {
            if (currentIndex >= 0) {
                const loc = locations[currentIndex];
                if (loc.locked) {
                    showTempMessage('Marker locked — unlock to delete!', 4000);
                    playSound('error');
                    return;
                }
                lastDeleted = { ...loc };
                locations.splice(currentIndex, 1);
                recalculateXP();
                closeModal(itemModal);
                saveLocations();
                forceReload();
                if (undoBtn) undoBtn.style.display = 'inline-block';
                showTempMessage('Deleted! Use Undo to restore.', 4000);
                playSound('delete');
            }
        };
    }
    if (undoBtn) {
        undoBtn.onclick = () => {
            if (lastDeleted) {
                locations.push(lastDeleted);
                lastDeleted = null;
                recalculateXP();
                saveLocations();
                forceReload();
                undoBtn.style.display = 'none';
                closeModal(itemModal);
                showTempMessage('Undo successful!', 3000);
                playSound('undo');
            }
        };
    }
    if (duplicateBtn) {
        duplicateBtn.onclick = () => {
            if (currentIndex >= 0) {
                const loc = locations[currentIndex];
                if (loc.locked) {
                    showTempMessage('Marker locked — unlock to duplicate!', 4000);
                    playSound('error');
                    return;
                }
                const baseOffset = 40 / Math.pow(2, map.getZoom());
                const angleStep = 60;
                const dupCount = locations.filter(l => l.cid === loc.cid && l.id !== loc.id).length;
                const angle = dupCount * angleStep * Math.PI / 180;
                const offsetX = baseOffset * Math.cos(angle);
                const offsetY = baseOffset * Math.sin(angle);
                const newLat = loc.lat + offsetY;
                const newLng = loc.lng + offsetX;
                const newDesc = updateDescWithGrid(loc.desc, newLat, newLng);
                const newLoc = createNewLocation(newLat, newLng, loc.category, newDesc);
                newLoc.userCid = loc.cid;
                locations.push(newLoc);
                recalculateXP();
                saveLocations();
                forceReload();
                closeModal(itemModal);
                safeFlyTo(newLoc.lat, newLng, map.getZoom());
                showTempMessage('Duplicated — new copy is LOCKED!', 3000);
                playSound('duplicate');
            }
        };
    }
    if (shareItemBtn) {
        shareItemBtn.onclick = () => {
            const loc = locations[currentIndex];
            const lat = loc.lat.toFixed(0);
            const lng = loc.lng.toFixed(0);
            const grid = getGridFromLatLng(loc.lat, loc.lng);
            const desc = loc.desc.split('\n')[0].trim();
            const url = `${window.location.origin}${window.location.pathname}?lat=${lat}&lng=${lng}&grid=${grid}&desc=${encodeURIComponent(desc)}`;
            navigator.clipboard.writeText(url).then(() => {
                showTempMessage('Share link copied!', 3000);
                playSound('click');
            }).catch(() => {
                prompt('Copy this link:', url);
            });
        };
    }
    if (categoryFilter) {
        categoryFilter.addEventListener('change', () => {
            const val = categoryFilter.value;
            localStorage.setItem('currentCategoryFilter', val);
            loadData(combinedSearch ? combinedSearch.value : '', val);
            playSound('selectcategory');
        });
    }

    /* DEV NOTE: MAP INTERACTIONS */
    map.on('dragstart', () => { isDraggingAny = true; });
    map.on('dragend', () => { setTimeout(() => { isDraggingAny = false; }, 400); });
    map.on('movestart', () => { isDraggingAny = true; });
    map.on('moveend', () => { setTimeout(() => { isDraggingAny = false; }, 400); });

    const coordHoverControl = L.control({ position: 'bottomleft' });
    coordHoverControl.onAdd = function() {
        const div = L.DomUtil.create('div', 'coord-hover');
        div.innerHTML = '';
        return div;
    };
    coordHoverControl.addTo(map);
    const hoverCoordsHandler = (e) => {
        if (isDraggingAny) return;
        let lat, lng;
        if (e.touches) {
            const touch = e.touches[0];
            lat = map.mouseEventToLatLng({ clientX: touch.clientX, clientY: touch.clientY }).lat;
            lng = map.mouseEventToLatLng({ clientX: touch.clientX, clientY: touch.clientY }).lng;
        } else {
            lat = e.latlng.lat;
            lng = e.latlng.lng;
        }
        const grid = getGridFromLatLng(lat, lng);
        const x = Math.round(lng);
        const y = Math.round(lat);
        coordHoverControl.getContainer().innerHTML = `Grid: ${grid || 'N/A'} (X: ${x}, Y: ${y})`;
        coordHoverControl.getContainer().classList.add('show');
    };
    map.on('mousemove', hoverCoordsHandler);
    map.on('touchmove', hoverCoordsHandler);
    map.getContainer().addEventListener('mouseleave', () => {
        coordHoverControl.getContainer().classList.remove('show');
    });

    map.on('click', e => {
        if (isDraggingAny) {
            isDraggingAny = false;
            return;
        }
        if (!gridEnabled) {
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            const grid = getGridFromLatLng(lat, lng);
            const x = Math.round(lng);
            const y = Math.round(lat);
            coordHoverControl.getContainer().innerHTML = `Grid: ${grid || 'N/A'} (X: ${x}, Y: ${y})`;
            coordHoverControl.getContainer().classList.add('show');
            setTimeout(() => coordHoverControl.getContainer().classList.remove('show'), 3000);
        }
        if (gridEnabled) {
            const grid = getGridFromLatLng(e.latlng.lat, e.latlng.lng);
            if (grid) showGridNotification(grid);
        }
        playSound('click');
    });

    map.on('contextmenu', e => {
        L.DomEvent.preventDefault(e);
        const lat = e.latlng.lat;
        const lng = e.latlng.lng;
        const grid = getGridFromLatLng(lat, lng);
        const x = Math.round(lng);
        const y = Math.round(lat);
        const desc = grid ? `Grid ${grid} (X: ${x}, Y: ${y})` : `X: ${x}, Y: ${y}`;
        const url = `${window.location.origin}${window.location.pathname}?lat=${y}&lng=${x}&grid=${grid}&desc=${encodeURIComponent(desc)}`;
        navigator.clipboard.writeText(url).then(() => {
            showTempMessage('Right-click location copied!', 3000);
            playSound('click');
        }).catch(() => {
            prompt('Copy this link:', url);
        });
        if (grid) showGridNotification(grid);
    });

    map.on('dblclick', e => {
        L.DomEvent.stopPropagation(e);
        tempLatLng = { lat: e.latlng.lat, lng: e.latlng.lng };
        openModal('Log Item');
        playSound('click');
    });

    const edgePanBuffer = 50;
    let edgePanInterval = null;
    map.getContainer().addEventListener('mousemove', e => {
        if (isDraggingAny) return;
        const rect = map.getContainer().getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const w = rect.width;
        const h = rect.height;
        let dx = 0, dy = 0;
        if (x < edgePanBuffer) dx = -10;
        if (x > w - edgePanBuffer) dx = 10;
        if (y < edgePanBuffer) dy = -10;
        if (y > h - edgePanBuffer) dy = 10;
        if (dx || dy) {
            if (!edgePanInterval) {
                edgePanInterval = setInterval(() => {
                    map.panBy([dx, dy]);
                }, 50);
            }
        } else if (edgePanInterval) {
            clearInterval(edgePanInterval);
            edgePanInterval = null;
        }
    });
    map.getContainer().addEventListener('mouseleave', () => {
        if (edgePanInterval) {
            clearInterval(edgePanInterval);
            edgePanInterval = null;
        }
    });
    map.getContainer().addEventListener('touchmove', e => {
        if (isDraggingAny) return;
        const touch = e.touches[0];
        const rect = map.getContainer().getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const w = rect.width;
        const h = rect.height;
        let dx = 0, dy = 0;
        if (x < edgePanBuffer) dx = -15;
        if (x > w - edgePanBuffer) dx = 15;
        if (y < edgePanBuffer) dy = -15;
        if (y > h - edgePanBuffer) dy = 15;
        if (dx || dy) {
            map.panBy([dx, dy]);
        }
    });

    /* DEV NOTE: URL PARAMETER HANDLING */
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('lat') && urlParams.has('lng')) {
        const lat = parseFloat(urlParams.get('lat'));
        const lng = parseFloat(urlParams.get('lng'));
        const grid = urlParams.get('grid') || getGridFromLatLng(lat, lng);
        const desc = urlParams.get('desc') ? decodeURIComponent(urlParams.get('desc')) : '';
        setTimeout(() => {
            safeFlyTo(lat, lng, 3);
            showTempMessage(`Shared: ${desc || grid}`, 5000);
            playSound('click');
        }, 1000);
    }

    /* DEV NOTE: INITIALIZE APP */
    updateCategoryDropdowns();
    renderCategoryToggles();
    loadData(currentSearch, currentCategoryFilter);
    drawGrid();
    updateXPBar();

    /* DEV NOTE: DARK MODE TOGGLE */
    if (toggleDarkModeBtn) {
        toggleDarkModeBtn.onclick = () => {
            darkMode = !darkMode;
            document.body.classList.toggle('dark-mode', darkMode);
            localStorage.setItem('darkMode', darkMode);
            toggleDarkModeBtn.textContent = darkMode ? 'Dark Mode: On' : 'Dark Mode: Off';
            playSound('click');
        };
    }

    /* DEV NOTE: UI LAYOUT INITIALIZATION */
    setTimeout(() => {
        const mapContainer = document.getElementById('map');
        const tableContainer = document.getElementById('tableContainer');
        if (!mapContainer || !tableContainer) return;
        let topBar = document.getElementById('topBar');
        if (!topBar) {
            topBar = document.createElement('div');
            topBar.id = 'topBar';
            topBar.className = 'top-bar';
            mapContainer.parentNode.insertBefore(topBar, mapContainer);
        }
        const originalTitle = document.getElementById('mainTitle');
        if (originalTitle && originalTitle.parentNode !== topBar) {
            topBar.appendChild(originalTitle);
        }
        const titleToggleBtn = document.getElementById('toggleTitleBtn');
        if (titleToggleBtn) {
            titleToggleBtn.onclick = () => {
                titleVisible = !titleVisible;
                topBar.classList.toggle('hidden', !titleVisible);
                titleToggleBtn.textContent = titleVisible ? '-' : '+';
                localStorage.setItem('titleVisible', titleVisible);
                playSound('click');
            };
            topBar.classList.toggle('hidden', !titleVisible);
        }
        mapContainer.classList.add('has-top-bar');
        let belowMapControls = document.getElementById('belowMapControls');
        if (!belowMapControls) {
            belowMapControls = document.createElement('div');
            belowMapControls.id = 'belowMapControls';
            mapContainer.parentNode.insertBefore(belowMapControls, tableContainer);
        }
        const searchBarEl = document.getElementById('searchBar');
        if (searchBarEl && searchBarEl.parentNode !== belowMapControls) {
            belowMapControls.appendChild(searchBarEl);
            searchBarEl.className = 'search-bar';
        }
        const buttonGroup = document.getElementById('buttonGroup');
        if (buttonGroup && buttonGroup.parentNode !== belowMapControls) {
            belowMapControls.appendChild(buttonGroup);
            buttonGroup.className = 'button-group';
        }
        let toolsToggleRow = document.getElementById('toolsToggleRow');
        if (!toolsToggleRow) {
            toolsToggleRow = document.createElement('div');
            toolsToggleRow.id = 'toolsToggleRow';
            toolsToggleRow.className = 'tools-toggle-row';
            mapContainer.parentNode.insertBefore(toolsToggleRow, belowMapControls.nextSibling);
        }
        const toggleButtonGroup = document.getElementById('toggleButtonGroup');
        if (toggleButtonGroup && toggleButtonGroup.parentNode !== toolsToggleRow) {
            toolsToggleRow.appendChild(toggleButtonGroup);
        }
        if (toggleButtonGroup && buttonGroup) {
            toggleButtonGroup.className = 'toggle-tools-btn';
            const toolsVisible = localStorage.getItem('toolsVisible') !== 'false';
            buttonGroup.classList.toggle('hidden', !toolsVisible);
            toggleButtonGroup.textContent = toolsVisible ? 'Hide Tools' : 'Show Tools';
            toggleButtonGroup.onclick = () => {
                const willShow = buttonGroup.classList.contains('hidden');
                buttonGroup.classList.toggle('hidden', !willShow);
                toggleButtonGroup.textContent = willShow ? 'Hide Tools' : 'Show Tools';
                localStorage.setItem('toolsVisible', willShow);
                playSound('click');
            };
        }
        const voiceSearchBtn = document.getElementById('voiceSearchBtn');
        if (voiceSearchBtn && buttonGroup) {
            if (voiceSearchBtn.parentNode !== buttonGroup) {
                buttonGroup.prepend(voiceSearchBtn);
            }
            voiceSearchBtn.className = 'voice-btn';
        }
        const counter = document.getElementById('counter');
        if (counter) counter.className = 'counter';
        let pagination = document.getElementById('tablePagination');
        if (!pagination) {
            pagination = document.createElement('div');
            pagination.id = 'tablePagination';
            pagination.className = 'pagination';
            const prev = document.getElementById('prevPageBtn');
            const info = document.getElementById('pageInfo');
            const next = document.getElementById('nextPageBtn');
            if (prev) pagination.appendChild(prev);
            if (info) pagination.appendChild(info);
            if (next) pagination.appendChild(next);
        }
        if (tableContainer && pagination && counter) {
            tableContainer.insertBefore(pagination, tableContainer.firstChild);
            tableContainer.insertBefore(counter, pagination.nextSibling);
        }
        let customHeader = document.getElementById('customTableHeader');
        if (!customHeader) {
            customHeader = document.createElement('div');
            customHeader.id = 'customTableHeader';
            customHeader.innerHTML = `
                <div style="display: table-row; background: rgba(0, 255, 0, 0.2); border: 1px solid #0f0; border-radius: 8px; width: 100% !important;">
                    <div style="display: table-cell; width: 10%; padding: 10px; text-align: center; color: #0f0; font-weight: bold;">Lock</div>
                    <div style="display: table-cell; width: 15%; padding: 10px; text-align: center; color: #0f0; font-weight: bold;">Icon</div>
                    <div style="display: table-cell; width: 25%; padding: 10px; text-align: center; color: #0f0; font-weight: bold;">Category</div>
                    <div style="display: table-cell; width: 50%; padding: 10px; text-align: center; color: #0f0; font-weight: bold; padding-left: 15px;">Description</div>
                </div>
            `;
            const table = tableContainer.querySelector('#locationsTable');
            if (table) tableContainer.insertBefore(customHeader, table);
        }
        document.body.classList.add('map-ready');
    }, 1000);

    /* --------------------------------------------------------------------------
       Fallout 76 Item Finder Map Version 37 - Disclaimer and Terms of Use
       --------------------------------------------------------------------------
       Copyright (c) 2025 MrCrazy. All rights reserved.
       This application, including all code, design, content, and the map images is the intellectual property of MrCrazy.
       Unauthorized use, copying, modification, distribution, or monetization of this application or any part thereof is strictly prohibited without explicit written permission from the author.
       This app is provided "as is" for personal, non-commercial use by Fallout 76 players to track in-game items.
       The author is not responsible for any damages or losses resulting from the use of this application. Use at your own risk.
       For inquiries or permission requests, call someone who cares.
       Last updated: November 04, 2025
       -------------------------------------------------------------------------- */
})();
});
</script>
</body>
</html>
