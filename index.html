<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Fallout 76 Item Finder VBETA</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="icon" href="https://raw.githubusercontent.com/mrcrazyapps/fallout76-item-finder/main/icon-192.png" sizes="192x192">
    <link rel="icon" href="https://raw.githubusercontent.com/mrcrazyapps/fallout76-item-finder/main/icon-512.png" sizes="512x512">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/mrcrazyapps/fallout76-item-finder/main/icon-192.png">
    <meta name="theme-color" content="#00ff00">
    <style>
        body { font-family: 'Courier New', monospace; margin: 20px; background-color: #0a2a2a; color: #00ff00; overflow-x: hidden; }
        h1 { color: #00ff00; text-align: center; text-shadow: 0 0 10px #00ff00; font-size: 2.2em; margin-bottom: 12px; }
        #map { height: 750px; border: 2px solid #00ff00; margin-bottom: 20px; box-shadow: 0 0 15px #00ff00; background-color: #000000; position: relative; }
        .controls { margin-bottom: 20px; text-align: center; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        input[type="text"], select { padding: 8px; width: 100%; max-width: 200px; box-sizing: border-box; border: 2px solid #00ff00; border-radius: 0; background-color: #1a3c34; color: #00ff00; font-family: 'Courier New', monospace; }
        #combinedSearch { max-width: 250px; transition: background-color 0.3s, box-shadow 0.3s; }
        #combinedSearch.grid-highlight, #combinedSearch.item-highlight { background-color: #0a3a0a !important; box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(0, 255, 0, 0.3); animation: pulseSearch 1.5s ease-out; }
        @keyframes pulseSearch { 0%, 100% { box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(0, 255, 0, 0.3); } 50% { box-shadow: 0 0 25px #00ff00, inset 0 0 15px rgba(0, 255, 0, 0.5); } }
        button { padding: 8px 16px; width: 100%; max-width: 200px; box-sizing: border-box; background-color: #1a3c34; color: #00ff00; border: 2px solid #00ff00; border-radius: 0; cursor: pointer; font-family: 'Courier New', monospace; transition: background-color 0.3s; margin: 5px; }
        button:hover { background-color: #00ff00; color: #0a2a2a; }
        button.reset-btn { background-color: #F7615E !important; color: #000 !important; font-weight: 700; }
        p { max-width: 800px; margin: 0 auto 20px; text-align: center; text-shadow: 0 0 5px #00ff00; }
        /* TABLE CONTAINER */
        #tableContainer {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            overflow-x: auto !important;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            contain: paint;
            padding: 10px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #0f0;
            border-radius: 8px;
        }
        /* FAKE HEADER + CARD ROWS */
        #customTableHeader {
            display: table !important;
            width: 100% !important;
            table-layout: fixed !important;
            border-spacing: 0 12px !important;
            margin-bottom: -12px !important;
        }
        #customTableHeader > div {
            display: table-row !important;
            background: rgba(0, 255, 0, 0.2) !important;
            border: 1px solid #0f0 !important;
            border-radius: 8px !important;
        }
        #customTableHeader > div > div {
            display: table-cell !important;
            padding: 10px !important;
            text-align: center !important;
            color: #0f0 !important;
            font-weight: bold !important;
        }
        /* REAL TABLE - CARD ROWS ONLY */
        #locationsTable {
            width: 100% !important;
            border-collapse: separate !important;
            border-spacing: 0 12px !important;
            table-layout: fixed !important;
            margin: 0 !important;
        }
        #locationsTable thead { display: none !important; }
        #locationsTable tbody { display: block !important; width: 100% !important; }
        #locationsTable tbody tr {
            display: table-row !important;
            background: rgba(0, 0, 0, 0.4) !important;
            border: 1px solid #0f0 !important;
            border-radius: 8px !important;
            transition: all 0.3s ease !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }
        #locationsTable tbody tr:hover {
            background: rgba(0, 255, 0, 0.08) !important;
            box-shadow: 0 0 8px #0f0 !important;
        }
        #locationsTable tbody tr.glowing {
            background: rgba(0, 255, 0, 0.15) !important;
            box-shadow: 0 0 12px #0f0, 0 0 20px #0f0 !important;
            animation: tablePulse 1.5s infinite ease-in-out !important;
            border: 2px solid #00ff88 !important;
        }
        @keyframes tablePulse {
            0%, 100% { box-shadow: 0 0 12px #0f0, 0 0 20px #0f0; }
            50% { box-shadow: 0 0 18px #0f0, 0 0 30px #0f0; }
        }
        #locationsTable tbody td {
            padding: 10px !important;
            vertical-align: middle !important;
            text-align: center !important;
            word-wrap: break-word !important;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* COLUMN WIDTHS */
        #customTableHeader > div > div:nth-child(1),
        #locationsTable tbody td:nth-child(1) { width: 10% !important; }
        #customTableHeader > div > div:nth-child(2),
        #locationsTable tbody td:nth-child(2) { width: 15% !important; }
        #customTableHeader > div > div:nth-child(3),
        #locationsTable tbody td:nth-child(3) { width: 25% !important; }
        #customTableHeader > div > div:nth-child(4),
        #locationsTable tbody td:nth-child(4) {
            width: 50% !important;
            text-align: left !important;
            padding-left: 15px !important;
            white-space: normal !important;
        }
        /* ICON / TEXT CELLS */
        .icon-circle { 
            width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto; font-size: 16px; font-weight: bold; color: #000;
        }
        .text-location { 
            background: #000; color: #fff; padding: 2px 6px; border: 1px solid #0f0; border-radius: 3px; font-size: 11px; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; margin: 0 auto;
        }
        .lock-toggle { font-size: 18px; cursor: pointer; display: block; margin: 0 auto; }
        /* MODALS */
        .modal { display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden; background-color: rgba(0, 42, 42, 0.8); }
        .modal-content { background-color: #1a3c34; margin: 8% auto; padding: 16px; border: 2px solid #00ff00; width: 100%; max-width: 360px; box-sizing: border-box; border-radius: 0; color: #00ff00; font-family: 'Courier New', monospace; overflow-y: auto; max-height: 80vh; -webkit-overflow-scrolling: touch; }
        .close { color: #00ff00; float: right; font-size: 24px; font-weight: bold; line-height: 1; cursor: pointer; }
        .close:hover { color: #0a2a2a; }
        label { display: block; margin: 8px 0 4px; }
        textarea, input[type="text"] { width: 100%; padding: 8px; border: 2px solid #00ff00; border-radius: 0; background-color: #0a2a2a; color: #00ff00; font-family: 'Courier New', monospace; box-sizing: border-box; }
        textarea { height: 120px; }
        body.modal-open { overflow: hidden; position: fixed; width: 100%; height: 100%; }
        /* MARKERS */
        .custom-icon { display: flex; align-items: center; justify-content: center; }
        .marker-background { width: 30px; height: 30px; border-radius: 50%; opacity: 0.9; display: flex; align-items: center; justify-content: center; background-color: #808080; }
        .custom-icon.glowing { box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-button { display: inline-block; margin: 0 5px; padding: 5px 10px; }
        .tab-button.active { background-color: #00ff00; color: #0a2a2a; }
        .small { font-size: 0.9em; color: #aaf0a0; }
        .marker-cluster div { width: 30px; height: 30px; margin-left: 5px; margin-top: 5px; text-align: center; border-radius: 15px; font: bold 12px/30px "Helvetica Neue", Arial, Helvetica, sans-serif; background-color: #ffff00; color: #000000; }
        #xpStatus { text-align: center; margin-bottom: 20px; }
        progress { accent-color: #00ff00; width: 200px; }
        #categoryCheckboxes label { display: flex; align-items: center; margin: 5px 0; }
        #categoryCheckboxes input[type="checkbox"] { margin-right: 10px; }
        #buttonGroup { display: inline-block; }
        #tablePagination { text-align: center; margin: 10px 0; display: block; width: 100%; }
        #tablePagination button { margin: 0 5px; }
        .leaflet-popup-content { max-height: 200px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .leaflet-popup-content-wrapper { background-color: #1a3c34; color: #00ff00; font-family: 'Courier New', monospace; }
        .leaflet-popup-close-button { color: #00ff00 !important; font-size: 16px !important; }
        .leaflet-popup-close-button:hover { color: #0a2a2a !important; }
        .grid-line { pointer-events: none; stroke: rgba(0, 255, 0, 0.35); stroke-width: 1; stroke-dasharray: 4, 4; }
        .grid-label { font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; fill: #00ff00; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; pointer-events: none; text-anchor: middle; dominant-baseline: central; }
        #gridNotification { position: fixed; bottom: 20px; right: 20px; background: #0a3a0a; color: #00ff00; padding: 14px 22px; border: 2px solid #00ff00; border-radius: 0; font-weight: bold; font-family: 'Courier New', monospace; font-size: 15px; box-shadow: 0 0 20px #00ff00, 0 0 40px rgba(0, 255, 0, 0.3); z-index: 10000; opacity: 0; transform: translateY(20px); transition: opacity 0.4s ease, transform 0.3s ease; pointer-events: none; }
        #gridNotification.show { opacity: 1; transform: translateY(0); }
        .flash-green { animation: flashGreen 0.6s ease-out; }
        @keyframes flashGreen { 0% { border-color: #00ff00; } 50% { border-color: #00ff88; box-shadow: 0 0 15px #00ff88; } 100% { border-color: #00ff00; } }
        /* DARK MODE */
        body.dark-mode { background-color: #000; }
        body.dark-mode .modal-content,
        body.dark-mode #map,
        body.dark-mode input, body.dark-mode select, body.dark-mode button,
        body.dark-mode #locationsTable th, body.dark-mode #locationsTable td,
        body.dark-mode #customTableHeader > div {
            background-color: #0a0a0a !important; color: #00ff00 !important; border-color: #00ff00 !important;
        }
        body.dark-mode button:hover { background-color: #00ff00 !important; color: #000 !important; }
        /* MOBILE PORTRAIT FIX */
        @media (max-width: 768px) {
            #map { height: 600px; }
            .controls { flex-direction: column; align-items: center; }
            input[type="text"], select, button { width: 100%; max-width: 100%; margin: 5px 0; font-size: clamp(14px, 4vw, 16px); padding: clamp(10px, 2vw, 12px); }
            #combinedSearch { max-width: 100%; }
            .modal-content { max-width: 90%; padding: 12px; font-size: clamp(14px, 3.5vw, 16px); max-height: 80vh; overflow-y: auto; -webkit-overflow-scrolling: touch; }
            .close { font-size: clamp(20px, 5vw, 22px); }
            .grid-label { font-size: 12px; }
            #gridNotification { bottom: 10px; right: 10px; font-size: 13px; padding: 10px 16px; box-shadow: 0 0 15px #00ff00; }
            /* TABLE MOBILE */
            #tableContainer { padding: 8px; }
            #customTableHeader > div > div,
            #locationsTable tbody td {
                font-size: 11px !important;
                padding: 6px 4px !important;
            }
            #locationsTable tbody td:nth-child(4) {
                font-size: 10px !important;
                white-space: normal !important;
                line-height: 1.3 !important;
            }
            .icon-circle { width: 24px !important; height: 24px !important; font-size: 13px !important; }
            .text-location { font-size: 9px !important; max-width: 80px !important; }
        }
        .nuke-emoji-wrapper { text-align: center; margin: 12px 0; }
        .nuke-emoji-btn { display: inline-block; padding: 14px 18px; background: #001100; color: #00ff00 !important; font-size: 3.2em; text-decoration: none; border: 3px solid #00ff00; border-radius: 50%; box-shadow: 0 0 14px #00ff00; transition: all 0.25s ease; cursor: pointer; }
        .nuke-emoji-btn:hover { background: #002200; transform: scale(1.12) rotate(8deg); box-shadow: 0 0 22px #00ff00, 0 0 34px #00ff00; }
        .nuke-emoji-btn:active { transform: scale(0.96); }
        #voiceSearchBtn[disabled], #voiceSearchBtn[style*="opacity: 0.6"] { pointer-events: auto !important; }
        /* NO FLASH: Hide controls until ready */
        #searchBar, #buttonGroup, #belowMapControls, #toolsToggleRow, #topBar {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .map-ready #searchBar, .map-ready #buttonGroup,
        .map-ready #belowMapControls, .map-ready #toolsToggleRow,
        .map-ready #topBar {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Title Toggle -->
    <div style="text-align:center; margin-bottom:8px;">
        <button id="toggleTitleBtn" style="padding:2px 6px; font-size:0.9em; max-width:40px; margin:0 auto;">-</button>
    </div>
    <h1 id="mainTitle">The Fallout 76 Item Finder! Quickly log items while exploring Appalachia.</h1>
  
    <!-- SEARCH BAR + VOICE -->
    <div id="searchBar" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:center; margin:10px auto; padding:10px; background:rgba(0,0,0,0.5); border:1px solid #0f0; border-radius:8px; max-width:90%;">
        <input type="text" id="combinedSearch" placeholder="desc/cate/grid.." style="flex:1; min-width:200px; padding:8px; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;">
        <button id="clearSearchBtn" style="background:none; border:none; color:#00ff00; font-size:18px; cursor:pointer; display:none; padding:0 8px;">√ó</button>
        <select id="categoryFilter" style="padding:8px; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;"><option value="">All Categories</option></select>
        <button id="toggleCategoryModalBtn" style="padding:8px 12px; background:#1a3c34; color:#0f0; border:1px solid #0f0; border-radius:4px;">Toggle Categories</button>
    </div>
  
    <!-- MAP -->
    <div id="map"></div>
  
    <!-- TOOLS CONTAINER -->
    <div class="tools-container" id="buttonGroup" style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin:10px auto; padding:10px; background:rgba(0,0,0,0.5); border:1px solid #0f0; border-radius:8px; max-width:90%;">
        <button id="voiceSearchBtn">Voice Search</button>
        <button id="toggleClusterBtn">Clustering: On</button>
        <button id="toggleMapBtn">Show No-Name Map</button>
        <button id="toggleGridBtn">Grid: Off</button>
        <button id="toggleButtonGroup">Hide Tools</button>
        <button id="howToUseBtn">How to Use</button>
        <button id="nukeCodesBtn">Nuke Codes</button>
        <button id="toggleSoundsBtn">Sounds: On</button>
        <button id="exportJsonBtn">Export Markers</button>
        <button id="importBtn">Import Markers</button>
        <button id="downloadCommunityBtn" style="background:#00ff88; color:#000; font-weight:700;">Update Community Map</button>
        <button id="undoImportBtn" style="display:none; background:#cc8400; color:#000; font-weight:700;">UNDO IMPORT</button>
        <button id="saveMapJpegBtn">Save Map as JPEG</button>
        <button id="toggleDarkModeBtn">Dark Mode: Off</button>
    </div>
  
    <!-- XP STATUS -->
    <div id="xpStatus" style="text-align:center; margin:10px; color:#0f0; font-weight:bold;">Explorer Level: <span id="levelSpan">1</span><br>XP: <progress id="xpProgress" value="0" max="1000" style="width:200px;"></progress> <span id="xpText">0 / 1000</span></div>
  
    <!-- CONTENT INVENTORY -->
    <h2 style="text-align:center; margin:15px 0 5px;">Content Inventory</h2>
    <p id="counter" style="text-align:center; margin:0 0 10px; color:#0f0;"></p>
    <button id="toggleTableBtn" style="display:none; margin:0 auto 10px; padding:8px 16px; background:#1a3c34; color:#0f0; border:1px solid #0f0; border-radius:4px;">Show Content Table</button>
  
    <div id="tableContainer">
        <div id="tablePagination" style="text-align:center; margin-bottom:10px;">
            <button id="prevPageBtn" disabled style="padding:6px 12px; background:#1a3c34; color:#0f0; border:1px solid #0f0; border-radius:4px;">Prev</button>
            <span id="pageInfo" style="margin:0 15px; color:#0f0; font-weight:bold;">Page 1 of 1</span>
            <button id="nextPageBtn" disabled style="padding:6px 12px; background:#1a3c34; color:#0f0; border:1px solid #0f0; border-radius:4px;">Next</button>
        </div>
        <div id="customTableHeader"></div>
        <table id="locationsTable">
            <thead>
                <tr><th>Lock</th><th>Icon</th><th>Category</th><th>Description</th></tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
  
    <div id="gridNotification"></div>
   
    <!-- ITEM MODAL -->
    <div id="itemModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2 id="modalTitle">Log Item</h2>
            <label>Category:</label>
            <select id="itemCategory"></select>
            <label>Description:</label>
            <textarea id="itemDesc" placeholder="Enter item and location details or leave blank auto puts gid location"></textarea>
            <div style="margin-top:12px; text-align:center;">
                <button id="saveItemBtn" style="padding:8px 16px; background:#00ff00; color:#000; font-weight:700; border-radius:4px;">Save</button>
                <button id="shareItemBtn" style="padding:8px 16px; background:#ff0; color:#000; font-weight:700; border-radius:4px; margin:0 8px;">Share Link</button>
                <button id="deleteItemBtn" style="padding:8px 16px; background:#F7615E; color:#000; font-weight:700; border-radius:4px; display:none;">Delete</button>
                <button id="undoItemBtn" style="padding:8px 16px; background:#cc8400; color:#000; font-weight:700; border-radius:4px; display:none; margin:0 8px;">Undo Delete</button>
                <button id="duplicateItemBtn" style="padding:8px 16px; background:#5E99F7; color:#000; font-weight:700; border-radius:4px; display:none;">Duplicate</button>
            </div>
        </div>
    </div>
   
    <!-- INSTRUCTIONS + NUKE CODES MODAL -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h1>Fallout 76 Item Finder Info</h1>
            <div style="text-align:center; margin-bottom:10px;">
                <button id="showInstructionsTab" class="tab-button active">How to Use</button>
                <button id="showNukeCodesTab" class="tab-button">Nuke Codes</button>
            </div>
            <div id="instructionsContent" class="tab-content active">
                <p><br>Double left-click (or double tap on mobile) the map to log an item. Newly logged/duplicated/edited locations will highlight for 2 minutes.</p>
                <p>Unlock markers to drag them‚Äîdrop auto-saves new position + glows! Lock to protect from accidental moves.</p>
                <p>Right-click or long-press (on mobile) on markers to edit, delete, or duplicate them (undo available after delete). Edit or delete from the Content Inventory.</p>
                <p>Left-click any row in the Content Table to page scrolls to map + zooms to marker!</p>
                <p>Right-click row opens Edit menu + zooms.</p>
                <p>Use the search bar to filter by description or category or grid number.</p>
                <p>Toggle between the named and no-name map versions using the "Toggle Map" button.</p>
                <p>Click anywhere on the map to see the grid coordinate (e.g., C4) in a green popup!</p>
                <p>Toggle the grid overlay with the "Grid" button.</p>
                <p>Create custom categories in the Toggle Categories menu to organize your items.</p>
                <p>Export User created or All logged locations to save data or import others' markers (duplicates are skipped).</p>
                <p>Save a JPEG of the map to capture your current view with markers.</p>
                <p>Gain XP for logging new items and level up like in Fallout 76! Lose XP for deleting items.</p>
                <p>For offline use on Android or iOS, save this locally and open in Chrome, Firefox, or Safari. An internet connection is needed for the map and libraries on first load.</p>
                <p>Check the "Update Community Map" button periodically for the latest map version or to reset the app if you encounter issues. Find this tip in the "How to Use" section.</p>
                <button id="resetAppBtn" class="reset-btn" style="display:block; margin:20px auto; padding:10px 20px; background:#ff4444; color:#000; font-weight:700; border-radius:6px;">Reset App (for debugging only)</button>
                <p style="text-align:center;" class="small"><br>Love the Item Finder? Support MrCrazy with a <a href="https://buymeacoffee.com/mrcrazy" target="_blank" style="color:#00ff00;">Nuka-Cola</a>!</p>
                <p style="text-align:center;" class="small" id="appVersionText">The Fallout 76 Item Finder Map Version 36 Made By MrCrazy</p>
            </div>
            <div id="nukeCodesContent" class="tab-content">
                <p><strong><br>Nuke Codes</strong></p>
                <div id="nuke-codes" style="color:#00ff00;font-size:14px;">Loading codes‚Ä¶</div>
            </div>
        </div>
    </div>
   
    <!-- CATEGORY TOGGLE MODAL -->
    <div id="categoryToggleModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2>Toggle Categories</h2>
            <div style="margin-bottom:10px; text-align:center;">
                <button id="selectAllBtn">Select All</button>
                <button id="deselectAllBtn">Deselect All</button>
                <button id="createCategoryBtn">Create Category</button>
                <button id="deleteCategoryBtn">Delete Category</button>
            </div>
            <div id="categoryCheckboxes" style="max-height:300px; overflow-y:auto; padding:10px; background:rgba(0,0,0,0.5); border:1px solid #0f0; border-radius:4px;"></div>
            <button id="closeCategoryToggleBtn" style="display:block; margin:15px auto 0; padding:8px 16px; background:#00ff00; color:#000; font-weight:700; border-radius:4px;">Close</button>
        </div>
    </div>
   
    <!-- CREATE CATEGORY MODAL -->
    <div id="createCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2>Create New Category</h2>
            <label>Category Name:</label>
            <input type="text" id="newCategoryName" placeholder="Enter category name" style="width:100%; padding:8px; margin:5px 0; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;">
            <label>Emoji (only one):</label>
            <input type="text" id="newCategoryEmoji" placeholder="Paste emoji" maxlength="2" inputmode="text" style="width:100%; padding:8px; margin:5px 0; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;">
            <p class="small">Paste one emoji. Only emojis allowed.</p>
            <div style="margin-top:12px; text-align:center;">
                <button id="saveCategoryBtn" style="padding:8px 16px; background:#00ff00; color:#000; font-weight:700; border-radius:4px;">Save Category</button>
            </div>
        </div>
    </div>
   
    <!-- DELETE CATEGORY MODAL -->
    <div id="deleteCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close">X</span>
            <h2>Delete Category</h2>
            <label>Select Category to Delete:</label>
            <select id="deleteCategorySelect" style="width:100%; padding:8px; margin:5px 0; background:#000; color:#0f0; border:1px solid #0f0; border-radius:4px;">
                <option value="">Select a custom category</option>
            </select>
            <p class="small">Deleting a category will reassign all its markers to "misc".</p>
            <div style="margin-top:12px; text-align:center;">
                <button id="confirmDeleteCategoryBtn" style="padding:8px 16px; background:#ff4444; color:#000; font-weight:700; border-radius:4px;">Delete Category</button>
            </div>
        </div>
    </div>
<script>
document.addEventListener('DOMContentLoaded', function() {
    (function() {
        const STORAGE_KEY = 'fallout76_locations';
        const CUSTOM_CATEGORIES_KEY = 'fallout76_custom_categories';
        const MAP_VERSION_KEY = 'fallout76_map_version';
        const TERMS_ACCEPTED_KEY = 'fallout76_terms_accepted';
        const UPDATE_VERSION_KEY = 'fallout76_last_update_seen';
        const CURRENT_UPDATE_VERSION = 'v35-drag-commit';
        const APP_VERSION = "36";
        let soundsEnabled = localStorage.getItem('soundsEnabled') !== 'false';
        const baseSounds = {
            click: new Audio("https://rpg.hamsterrepublic.com/wiki-images/8/84/Select8-Bit.ogg"),
            type: new Audio("https://rpg.hamsterrepublic.com/wiki-images/3/3a/Thip.ogg"),
            error: new Audio("https://rpg.hamsterrepublic.com/wiki-images/1/12/Ping-da-ding-ding-ding.ogg"),
            duplicate: new Audio("https://rpg.hamsterrepublic.com/wiki-images/0/0b/Robot_2.ogg"),
            saving: new Audio("https://rpg.hamsterrepublic.com/wiki-images/9/9c/Robot_1.ogg"),
            undo: new Audio("https://rpg.hamsterrepublic.com/wiki-images/d/d7/Oddbounce.ogg"),
            delete: new Audio("https://rpg.hamsterrepublic.com/wiki-images/0/04/TextboxBloop8-Bit.ogg"),
            levelUp: new Audio("https://rpg.hamsterrepublic.com/wiki-images/d/d5/Menu8-Bit.ogg"),
            modalClose: new Audio("https://rpg.hamsterrepublic.com/wiki-images/8/8e/Confirm8-Bit.ogg"),
            selectcategory: new Audio("https://rpg.hamsterrepublic.com/wiki-images/a/a8/Rolling_Switch.ogg")
        };
        Object.values(baseSounds).forEach(s => { s.volume = 0.15; });
        function playSound(type) {
            if (soundsEnabled && baseSounds[type]) {
                baseSounds[type].currentTime = 0;
                baseSounds[type].play().catch(() => {});
            }
        }
        function generateUniqueId() { return 'id-' + crypto.randomUUID(); }
        function generateCid(loc) {
            const desc = (loc.desc || '').toString().toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, '_');
            const lat = Math.round(loc.lat);
            const lng = Math.round(loc.lng);
            return `${loc.category}_${desc}_${lat}_${lng}`;
        }
        let locations = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
        locations.forEach(loc => {
            if (!loc.id) loc.id = generateUniqueId();
            if (!loc.cid && loc.category && loc.desc && loc.lat && loc.lng) {
                loc.cid = generateCid(loc);
            }
            if (loc.locked === undefined) loc.locked = false;
        });
        localStorage.setItem(STORAGE_KEY, JSON.stringify(locations));
        let customCategories = JSON.parse(localStorage.getItem(CUSTOM_CATEGORIES_KEY)) || {};
        let communityVersion = localStorage.getItem(MAP_VERSION_KEY) || "1.0";
        let termsAccepted = localStorage.getItem(TERMS_ACCEPTED_KEY) === 'true';
        let lastImportBackup = null;
        const defaultCategoryIcons = {
        'weapons': 'üî´', 'armor': 'üõ°Ô∏è', 'aid': 'üíâ', 'food/drink': 'üçΩÔ∏è', 'ammunition': 'üí•',
        'apparel': 'üëï', 'plans': 'üìú', 'junk': 'üóëÔ∏è', 'holotapes': 'üìÄ', 'misc': 'üìù',
        'plants': 'üåø', 'eggs': 'ü•ö', 'creatures': 'üê∫', 'vendors': 'üí∞', 'exchanges': '‚öñÔ∏è',
        'vaults': '‚öôÔ∏è', 'power armor': 'üë®‚ÄçüöÄ', 'fusion core': 'üîã', 'nuke drop zones': '‚ò¢Ô∏è',
        'nuke silos': 'üöÄ', 'magazines': 'üìö', 'bobbleheads': 'üéé', 'safe locations': 'üóÑÔ∏è',
        'terminal locations': 'üñ•Ô∏è', 'treasure maps': 'üó∫Ô∏è', 'resource deposits': '‚õèÔ∏è',
        'fishing locations': 'üé£', 'workshops': 'üîß', 'train stations': 'üöÇ', 'town locations': 'üè´',
        'event locations': 'üéâ', 'named locations': 'üö©', 'regions': 'üìç'
        };
        let categoryIcons = { ...defaultCategoryIcons, ...customCategories };
        const defaultCategoryColors = {
            'weapons': '#ff4444', 'armor': '#4682b4', 'aid': '#32cd32', 'food/drink': '#adff2f',
            'ammunition': '#ff8c00', 'apparel': '#dda0dd', 'plans': '#a0522d', 'junk': '#808080',
            'holotapes': '#f0e68c', 'misc': '#f0e68c', 'plants': '#228b22', 'eggs': '#f5f5dc',
            'creatures': '#8b0000', 'vendors': '#ffd700', 'exchanges': '#20b2aa', 'vaults': '#4682b4',
            'power armor': '#b22222', 'fusion core': '#ff4500', 'nuke drop zones': '#ff0000',
            'nuke silos': '#dc143c', 'magazines': '#ff69b4', 'bobbleheads': '#00b7eb',
            'treasure maps': '#d2b48c', 'resource deposits': '#696969', 'fishing locations': '#1e90ff',
            'workshops': '#b8860b', 'train stations': '#a9a9a9', 'town locations': '#228b22',
            'regions': '#00ff00', 'named locations': '#ffffff'
        };
        let categoryColors = { ...defaultCategoryColors };
        const map = L.map('map', { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: true, scrollWheelZoom: true, doubleClickZoom: true, boxZoom: true, touchZoom: true, dragging: true, keyboard: true });
        const imageBounds = [[0, 0], [4096, 4096]];
        const mapUrls = {
            named: 'https://i.postimg.cc/HpqMVWjB/Mappalachia-Map-of-Appalachia.jpg',
            noName: 'https://i.postimg.cc/y6W7JMKB/Mappalachia-Map-of-Appalachia-no-name.jpg'
        };
        let currentMap = localStorage.getItem('currentMap') || 'named';
        let imageOverlay = L.imageOverlay(mapUrls[currentMap], imageBounds).addTo(map);
        map.fitBounds(imageBounds);
        const clusteredMarkers = L.markerClusterGroup({ maxClusterRadius: 30, disableClusteringAtZoom: 2 });
        const nonClusteredMarkers = L.layerGroup();
        map.addLayer(clusteredMarkers);
        map.addLayer(nonClusteredMarkers);
        let lastDeleted = null;
        let currentIndex = -1;
        let tempLatLng = { lat: 0, lng: 0 };
        let clusteringEnabled = localStorage.getItem('clusteringEnabled') !== 'false';
        let gridEnabled = localStorage.getItem('gridEnabled') === 'true';
        let activeCategories = new Set(
            localStorage.getItem('activeCategories')
                ? JSON.parse(localStorage.getItem('activeCategories'))
                : Object.keys(defaultCategoryIcons)
        );
        let level = parseInt(localStorage.getItem('fo76_level')) || 1;
        let xp = parseInt(localStorage.getItem('fo76_xp')) || 0;
        const xpPerLevel = 1000;
        const xpPerMarker = 100;
        const pageSize = 100;
        let tablePage = parseInt(localStorage.getItem('tablePage')) || 1;
        let tableVisible = localStorage.getItem('tableVisible') !== 'false';
        let currentSearch = localStorage.getItem('currentSearch') || '';
        let currentCategoryFilter = localStorage.getItem('currentCategoryFilter') || '';
        let darkMode = localStorage.getItem('darkMode') === 'true';
        let gridLayer = L.layerGroup().addTo(map);
        let isDraggingAny = false;
        function drawGrid() {
            gridLayer.clearLayers();
            if (!gridEnabled) return;
            const gridSize = 10;
            const cellSize = 4096 / gridSize;
            for (let i = 0; i <= gridSize; i++) {
                const x = i * cellSize;
                L.polyline([[0, x], [4096, x]], { className: 'grid-line', color: '#0f0', weight: 1, opacity: 0.5 }).addTo(gridLayer);
                const y = i * cellSize;
                L.polyline([[y, 0], [y, 4096]], { className: 'grid-line', color: '#0f0', weight: 1, opacity: 0.5 }).addTo(gridLayer);
            }
            const letters = 'ABCDEFGHIJ'.split('');
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const centerX = col * cellSize + cellSize / 2;
                    const centerY = row * cellSize + cellSize / 2;
                    const label = `${letters[col]}${row + 1}`;
                    L.marker([centerY, centerX], {
                        icon: L.divIcon({ className: 'grid-label', html: label, iconSize: [30, 30], iconAnchor: [15, 15] })
                    }).addTo(gridLayer);
                }
            }
        }
        function getGridFromLatLng(lat, lng) {
            const gridSize = 10;
            const cellSize = 4096 / gridSize;
            const col = Math.floor(lng / cellSize);
            const row = Math.floor(lat / cellSize);
            const letters = 'ABCDEFGHIJ';
            if (col >= 0 && col < letters.length && row >= 0 && row < gridSize) {
                return `${letters[col]}${row + 1}`;
            }
            return null;
        }
        function getLatLngFromGrid(grid) {
            const match = grid.toUpperCase().match(/^([A-J])(\d+)$/);
            if (!match) return null;
            const letters = 'ABCDEFGHIJ';
            const col = letters.indexOf(match[1]);
            const row = parseInt(match[2], 10) - 1;
            if (col === -1 || row < 0 || row >= 10) return null;
            const gridSize = 10;
            const cellSize = 4096 / gridSize;
            const centerX = col * cellSize + cellSize / 2;
            const centerY = row * cellSize + cellSize / 2;
            return { lat: centerY, lng: centerX };
        }
        function showGridNotification(grid) {
            const notif = document.getElementById('gridNotification');
            if (!notif) return;
            notif.textContent = `Grid: ${grid}`;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 3000);
        }
        function highlightSearchBar(type = 'grid') {
            const search = document.getElementById('combinedSearch');
            if (!search) return;
            search.classList.remove('grid-highlight', 'item-highlight');
            search.classList.add(type === 'grid' ? 'grid-highlight' : 'item-highlight');
            setTimeout(() => search.classList.remove(type === 'grid' ? 'grid-highlight' : 'item-highlight'), 1500);
        }
        function isValidEmoji(str) {
            if (!str || str.length === 0) return false;
            const emojiRegex = /^\p{Emoji}$/u;
            return emojiRegex.test(str.trim());
        }
        function updateDescWithGrid(desc, lat, lng) {
            const grid = getGridFromLatLng(lat, lng);
            const x = Math.round(lng);
            const y = Math.round(lat);
            const newCoords = grid ? `Grid ${grid} (X: ${x}, Y: ${y})` : `X: ${x}, Y: ${y}`;
            const regex = /(Grid [A-J]\d+ \(X: \d+, Y: \d+\))|(X: \d+, Y: \d+)/;
            if (regex.test(desc)) {
                return desc.replace(regex, newCoords);
            }
            return desc + '\n' + newCoords;
        }
        const itemModal = document.getElementById('itemModal');
        const deleteBtn = document.getElementById('deleteItemBtn');
        const undoBtn = document.getElementById('undoItemBtn');
        const duplicateBtn = document.getElementById('duplicateItemBtn');
        const shareItemBtn = document.getElementById('shareItemBtn');
        const modalTitle = document.getElementById('modalTitle');
        const itemCategorySelect = document.getElementById('itemCategory');
        const itemDescInput = document.getElementById('itemDesc');
        const toggleSoundsBtn = document.getElementById('toggleSoundsBtn');
        const toggleClusterBtn = document.getElementById('toggleClusterBtn');
        const toggleMapBtn = document.getElementById('toggleMapBtn');
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const toggleButtonGroup = document.getElementById('toggleButtonGroup');
        const buttonGroup = document.getElementById('buttonGroup');
        const combinedSearch = document.getElementById('combinedSearch');
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const categoryFilter = document.getElementById('categoryFilter');
        const levelSpan = document.getElementById('levelSpan');
        const xpProgress = document.getElementById('xpProgress');
        const xpText = document.getElementById('xpText');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const tableContainer = document.getElementById('tableContainer');
        const toggleTableBtn = document.getElementById('toggleTableBtn');
        const counter = document.getElementById('counter');
        const categoryToggleModal = document.getElementById('categoryToggleModal');
        const toggleCategoryModalBtn = document.getElementById('toggleCategoryModalBtn');
        const howToUseBtn = document.getElementById('howToUseBtn');
        const nukeCodesBtn = document.getElementById('nukeCodesBtn');
        const exportBtn = document.getElementById('exportJsonBtn');
        const importBtn = document.getElementById('importBtn');
        const downloadCommunityBtn = document.getElementById('downloadCommunityBtn');
        const saveJpegBtn = document.getElementById('saveMapJpegBtn');
        const resetAppBtn = document.getElementById('resetAppBtn');
        const newCategoryEmoji = document.getElementById('newCategoryEmoji');
        const toggleDarkModeBtn = document.getElementById('toggleDarkModeBtn');
        const voiceSearchBtn = document.getElementById('voiceSearchBtn');
        const undoImportBtn = document.getElementById('undoImportBtn');
        if (toggleSoundsBtn) toggleSoundsBtn.textContent = soundsEnabled ? 'Sounds: On' : 'Sounds: Off';
        if (toggleClusterBtn) toggleClusterBtn.textContent = `Clustering: ${clusteringEnabled ? 'On' : 'Off'}`;
        if (toggleMapBtn) toggleMapBtn.textContent = currentMap === 'named' ? 'Show No-Name Map' : 'Show Named Map';
        if (toggleGridBtn) toggleGridBtn.textContent = `Grid: ${gridEnabled ? 'On' : 'Off'}`;
        if (buttonGroup) buttonGroup.style.display = 'flex';
        if (toggleButtonGroup) toggleButtonGroup.textContent = 'Hide Tools';
        if (combinedSearch) combinedSearch.value = currentSearch;
        if (categoryFilter) categoryFilter.value = currentCategoryFilter;
        const toggleTitleBtn = document.getElementById('toggleTitleBtn');
        let titleVisible = localStorage.getItem('titleVisible') !== 'false';
        const topBar = document.getElementById('topBar');
        if (topBar) topBar.style.display = titleVisible ? 'flex' : 'none';
        if (toggleTitleBtn) toggleTitleBtn.textContent = titleVisible ? '-' : '+';
        if (toggleTitleBtn) {
            toggleTitleBtn.onclick = () => {
                titleVisible = !titleVisible;
                if (topBar) topBar.style.display = titleVisible ? 'flex' : 'none';
                toggleTitleBtn.textContent = titleVisible ? '-' : '+';
                localStorage.setItem('titleVisible', titleVisible);
                playSound('click');
            };
        }
        document.body.classList.toggle('dark-mode', darkMode);
        if (toggleDarkModeBtn) {
            toggleDarkModeBtn.textContent = darkMode ? 'Dark Mode: On' : 'Dark Mode: Off';
            toggleDarkModeBtn.onclick = () => {
                darkMode = !darkMode;
                document.body.classList.toggle('dark-mode', darkMode);
                localStorage.setItem('darkMode', darkMode);
                toggleDarkModeBtn.textContent = darkMode ? 'Dark Mode: On' : 'Dark Mode: Off';
                playSound('click');
            };
        }
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition && voiceSearchBtn) {
            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            voiceSearchBtn.onclick = () => {
                if (voiceSearchBtn.textContent === 'Listening...') {
                    recognition.stop();
                    voiceSearchBtn.textContent = 'Voice Search';
                    return;
                }
                if (combinedSearch) combinedSearch.value = '';
                combinedSearch.focus();
                recognition.start();
                voiceSearchBtn.textContent = 'Listening...';
                playSound('click');
            };
            recognition.onresult = e => {
                const transcript = e.results[0][0].transcript.trim();
                if (combinedSearch) combinedSearch.value = transcript;
                loadData(transcript, categoryFilter ? categoryFilter.value : '');
                voiceSearchBtn.textContent = 'Voice Search';
                showTempMessage(`Heard: "${transcript}"`, 4000);
                playSound('selectcategory');
            };
            recognition.onerror = () => {
                voiceSearchBtn.textContent = 'Voice Search';
                showTempMessage('Voice failed. Try again or type.', 3000);
                playSound('error');
            };
            recognition.onend = () => {
                voiceSearchBtn.textContent = 'Voice Search';
            };
        } else if (voiceSearchBtn) {
            voiceSearchBtn.style.display = 'inline-block';
            voiceSearchBtn.textContent = 'Voice Search (Chrome/Edge only)';
            voiceSearchBtn.title = 'Voice Search requires Chrome or Edge';
            voiceSearchBtn.style.opacity = '0.6';
            voiceSearchBtn.style.cursor = 'help';
            voiceSearchBtn.onclick = () => {
                showTempMessage('Voice Search only works in Chrome or Edge', 4000);
                playSound('error');
            };
        }
        let typingTimeout;
        let lastFilteredCount = -1;
        if (combinedSearch) {
            combinedSearch.addEventListener('input', () => {
                if (clearSearchBtn) clearSearchBtn.style.display = combinedSearch.value ? 'block' : 'none';
                const val = combinedSearch.value.trim();
                localStorage.setItem('currentSearch', val);
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => playSound('type'), 150);
                const filtered = locations.filter(loc => {
                    if (!activeCategories.has(loc.category)) return false;
                    if (categoryFilter && categoryFilter.value && loc.category !== categoryFilter.value) return false;
                    if (!val) return true;
                    return normalizeString(loc.desc + loc.category).includes(normalizeString(val));
                });
                if (lastFilteredCount !== -1 && filtered.length !== lastFilteredCount) {
                    playSound('selectcategory');
                }
                lastFilteredCount = filtered.length;
                if (!val) {
                    loadData('', categoryFilter ? categoryFilter.value : '');
                } else {
                    const gridMatch = val.toUpperCase().match(/^([A-J])(\d+)$/);
                    if (gridMatch) {
                        highlightSearchBar('grid');
                        const coords = getLatLngFromGrid(val.toUpperCase());
                        if (coords) {
                            safeFlyTo(coords.lat, coords.lng, 2);
                            showGridNotification(val.toUpperCase());
                        }
                    } else if (val.length > 0) {
                        highlightSearchBar('item');
                    }
                    loadData(val, categoryFilter ? categoryFilter.value : '');
                }
            });
        }
        if (clearSearchBtn) {
            clearSearchBtn.onclick = () => {
                if (combinedSearch) combinedSearch.value = '';
                clearSearchBtn.style.display = 'none';
                localStorage.setItem('currentSearch', '');
                loadData('', categoryFilter ? categoryFilter.value : '');
                combinedSearch.focus();
                playSound('modalClose');
            };
        }
        function fetchWithTimeout(url, ms = 10000) {
            return Promise.race([
                fetch(url),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))
            ]);
        }
        function fetchNukeCodes() {
            const codesDiv = document.getElementById('nuke-codes');
            if (!codesDiv) return;
            codesDiv.innerHTML = `
            <em>Visit the site to view Alpha, Bravo, and Charlie codes for this week.
            Weekly launch codes are always up to date!</em><br>
        
            <div class="nuke-emoji-wrapper">
                <a href="https://www.falloutbuilds.com/fo76/nuke-codes/"
                   target="_blank"
                   rel="noopener noreferrer"
                   class="nuke-emoji-btn"
                   title="Launch codes ‚Äì click the rocket">
                   üöÄ
                </a>
            </div>
        `;
        }
        const termsModal = document.createElement('div');
        termsModal.className = 'modal';
        termsModal.style.display = 'block';
        termsModal.innerHTML = `
            <div class="modal-content">
                <h2>Welcome to Fallout 76 Item Finder v${APP_VERSION}</h2>
                <p>By using this app, you agree to:</p>
                <ul>
                    <li>This app, created by MrCrazy, is for personal, non-commercial use by Fallout 76 players to track in-game items. Unauthorized copying, modification, distribution, or monetization is strictly prohibited. Do at your own risk.</li>
                    <li>Stay Updated!</li>
                    <li>Check the "Update Community Map" button periodically for the latest map version or to reset the app if you encounter issues. Find this tip in the "How to Use" section.</li>
                </ul>
                <p>Log and Track items in Appalachia with ease. Created by MrCrazy. Enjoy, and consider supporting with a <a href="https://buymeacoffee.com/mrcrazy" target="_blank" style="color:#00ff00;">Nuka-Cola</a>!</p>
                <button id="acceptTermsBtn" style="background:#00ff00;color:#000;font-weight:700;">I Accept Terms</button>
            </div>
        `;
        const allButtons = document.querySelectorAll('button, input, select');
        function setButtonsEnabled(enabled) {
            allButtons.forEach(btn => {
                if (btn.id !== 'acceptTermsBtn') {
                    btn.disabled = !enabled;
                    btn.style.opacity = enabled ? '1' : '0.5';
                    btn.style.pointerEvents = enabled ? 'auto' : 'none';
                }
            });
        }
        if (!termsAccepted) {
            document.body.appendChild(termsModal);
            document.body.classList.add('modal-open');
            setButtonsEnabled(false);
            const acceptBtn = document.getElementById('acceptTermsBtn');
            if (acceptBtn) {
                acceptBtn.onclick = () => {
                    localStorage.setItem(TERMS_ACCEPTED_KEY, 'true');
                    termsModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    setButtonsEnabled(true);
                    playSound('click');
                };
            }
        } else {
            setButtonsEnabled(true);
        }
        if (localStorage.getItem(UPDATE_VERSION_KEY) !== CURRENT_UPDATE_VERSION) {
            const updateModal = document.createElement('div');
            updateModal.className = 'modal';
            updateModal.style.display = 'block';
            updateModal.innerHTML = `
                <div class="modal-content" style="background:#0a3a0a; border:2px solid #00ff00; box-shadow:0 0 20px #00ff00;">
                    <span class="close">X</span>
                    <h2 style="color:#00ff00; text-shadow:0 0 10px #00ff00;">App Updated!</h2>
                    <p><strong>Action recommended:</strong><br>
                    Export your <strong>user-created markers</strong> to keep them safe!</p>
                    <div style="margin-top:12px; text-align:center;">
                        <button id="exportUserNowBtn" style="background:#00ff00; color:#000; font-weight:700; padding:8px 16px;">Export User Markers</button>
                        <button id="gotItUpdateBtn" style="margin-left:10px; background:#1a3c34; color:#00ff00;">Got it!</button>
                    </div>
                </div>
            `;
            document.body.appendChild(updateModal);
            document.body.classList.add('modal-open');
            const closeSpan = updateModal.querySelector('.close');
            if (closeSpan) {
                closeSpan.onclick = () => {
                    updateModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    localStorage.setItem(UPDATE_VERSION_KEY, CURRENT_UPDATE_VERSION);
                };
            }
            const gotItBtn = document.getElementById('gotItUpdateBtn');
            if (gotItBtn) {
                gotItBtn.onclick = () => {
                    updateModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    localStorage.setItem(UPDATE_VERSION_KEY, CURRENT_UPDATE_VERSION);
                    playSound('click');
                };
            }
            const exportUserBtn = document.getElementById('exportUserNowBtn');
            if (exportUserBtn) {
                exportUserBtn.onclick = () => {
                    playSound('saving');
                    const userMarkers = locations.filter(loc => loc.userEdited === true);
                    if (userMarkers.length === 0) {
                        alert("No user-created markers to export yet!");
                        return;
                    }
                    const exportData = {
                        version: 1.0,
                        note: "USER-ONLY backup ‚Äî safe to re-import",
                        locations: userMarkers,
                        customCategories: customCategories
                    };
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `fallout76_user_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                    showTempMessage(`Exported ${userMarkers.length} user markers!`, 4000);
                    updateModal.style.display = 'none';
                    document.body.classList.remove('modal-open');
                    localStorage.setItem(UPDATE_VERSION_KEY, CURRENT_UPDATE_VERSION);
                };
            }
        }
        const showInstructionsTab = document.getElementById('showInstructionsTab');
        if (showInstructionsTab) {
            showInstructionsTab.onclick = () => {
                const instructionsContent = document.getElementById('instructionsContent');
                const nukeCodesContent = document.getElementById('nukeCodesContent');
                if (instructionsContent) instructionsContent.classList.add('active');
                if (nukeCodesContent) nukeCodesContent.classList.remove('active');
                showInstructionsTab.classList.add('active');
                const showNukeTab = document.getElementById('showNukeCodesTab');
                if (showNukeTab) showNukeTab.classList.remove('active');
                playSound('click');
            };
        }
        const showNukeCodesTab = document.getElementById('showNukeCodesTab');
        if (showNukeCodesTab) {
            showNukeCodesTab.onclick = () => {
                const nukeCodesContent = document.getElementById('nukeCodesContent');
                const instructionsContent = document.getElementById('instructionsContent');
                if (nukeCodesContent) nukeCodesContent.classList.add('active');
                if (instructionsContent) instructionsContent.classList.remove('active');
                showNukeCodesTab.classList.add('active');
                const showInstTab = document.getElementById('showInstructionsTab');
                if (showInstTab) showInstTab.classList.remove('active');
                fetchNukeCodes();
                playSound('click');
            };
        }
        if (howToUseBtn) {
            howToUseBtn.onclick = () => {
                const instructionsModal = document.getElementById('instructionsModal');
                if (instructionsModal) instructionsModal.style.display = 'block';
                document.body.classList.add('modal-open');
                if (showInstructionsTab) showInstructionsTab.click();
                playSound('click');
            };
        }
        if (nukeCodesBtn) {
            nukeCodesBtn.onclick = () => {
                const instructionsModal = document.getElementById('instructionsModal');
                if (instructionsModal) instructionsModal.style.display = 'block';
                document.body.classList.add('modal-open');
                if (showNukeCodesTab) showNukeCodesTab.click();
                playSound('click');
            };
        }
        if (resetAppBtn) {
            resetAppBtn.onclick = () => {
                const keepUserMarkers = confirm(
                    "WARNING: This will DELETE ALL markers, categories, and settings.\n\n" +
                    "Keep your USER-CREATED markers?\n" +
                    "‚Ä¢ OK = Save them to a backup file\n" +
                    "‚Ä¢ CANCEL = Full reset (everything lost)\n\n" +
                    "Continue?"
                );
                if (!keepUserMarkers) {
                    if (confirm("FINAL WARNING: This cannot be undone. Are you ABSOLUTELY sure?")) {
                        localStorage.clear();
                        location.reload();
                    }
                    return;
                }
                const userMarkers = locations.filter(loc => loc.userEdited === true);
                if (userMarkers.length === 0) {
                    alert("No user-created markers to save. Proceeding with full reset.");
                    if (confirm("FINAL WARNING: This cannot be undone. Are you ABSOLUTELY sure?")) {
                        localStorage.clear();
                        location.reload();
                    }
                    return;
                }
                const backupData = {
                    version: 1.0,
                    note: "User-created markers backup ‚Äî safe to re-import",
                    locations: userMarkers,
                    customCategories: customCategories
                };
                const dataStr = JSON.stringify(backupData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `fallout76_user_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                link.click();
                URL.revokeObjectURL(url);
                alert(`Saved ${userMarkers.length} user markers to backup file!\n\nNow resetting app...`);
                setTimeout(() => {
                    if (confirm("FINAL WARNING: App will now reset. Continue?")) {
                        localStorage.clear();
                        location.reload();
                    }
                }, 500);
            };
        }
        if (newCategoryEmoji) {
            newCategoryEmoji.addEventListener('input', function(e) {
                const val = e.target.value;
                const clean = val.replace(/[^\p{Emoji}]/gu, '');
                if (val !== clean) e.target.value = clean;
            });
        }
        const saveCategoryBtn = document.getElementById('saveCategoryBtn');
        if (saveCategoryBtn) {
            saveCategoryBtn.onclick = () => {
                const nameInput = document.getElementById('newCategoryName');
                const emojiInput = document.getElementById('newCategoryEmoji');
                if (!nameInput || !emojiInput) return;
                const name = nameInput.value.trim();
                const emoji = emojiInput.value.trim();
                if (!name || categoryIcons[name]) {
                    if (nameInput) nameInput.classList.add('flash-green');
                    setTimeout(() => nameInput.classList.remove('flash-green'), 600);
                    return;
                }
                if (!isValidEmoji(emoji)) {
                    if (emojiInput) emojiInput.classList.add('flash-green');
                    setTimeout(() => emojiInput.classList.remove('flash-green'), 600);
                    return;
                }
                customCategories[name] = emoji;
                categoryIcons[name] = emoji;
                categoryColors[name] = '#f0e68c';
                activeCategories.add(name);
                localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                const createModal = document.getElementById('createCategoryModal');
                if (createModal) createModal.style.display = 'none';
                renderCategoryToggles();
                updateCategoryDropdowns();
                loadData();
                playSound('saving');
            };
        }
        function refreshTableVisibility() {
            const isMobile = window.innerWidth <= 768;
            if (toggleTableBtn) toggleTableBtn.style.display = isMobile ? 'block' : 'none';
            if (isMobile) {
                if (tableContainer) tableContainer.style.display = tableVisible ? 'block' : 'none';
                if (toggleTableBtn) toggleTableBtn.textContent = tableVisible ? 'Hide Content Table' : 'Show Content Table';
            }
        }
        function renderCategoryToggles() {
            const container = document.getElementById('categoryCheckboxes');
            if (!container) return;
            container.innerHTML = '';
            const allCats = [...Object.keys(defaultCategoryIcons), ...Object.keys(customCategories)].sort();
            allCats.forEach(cat => {
                const label = document.createElement('label');
                const checked = activeCategories.has(cat) ? 'checked' : '';
                label.innerHTML = `<input type="checkbox" value="${cat}" ${checked}><span>${cat} ${categoryIcons[cat] || ''}</span>`;
                container.appendChild(label);
            });
            container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', () => {
                    const val = cb.value;
                    if (cb.checked) activeCategories.add(val);
                    else activeCategories.delete(val);
                    localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                    loadData(combinedSearch.value, categoryFilter.value);
                    playSound('selectcategory');
                });
            });
        }
        function updateCategoryDropdowns() {
            const categories = [...Object.keys(defaultCategoryIcons), ...Object.keys(customCategories)].sort();
            const makeOption = cat => `<option value="${cat}">${cat} ${categoryIcons[cat] || ''}</option>`;
            if (categoryFilter) categoryFilter.innerHTML = '<option value="">All Categories</option>' + categories.map(makeOption).join('');
            if (itemCategorySelect) itemCategorySelect.innerHTML = categories.map(makeOption).join('');
            if (currentCategoryFilter && categories.includes(currentCategoryFilter) && categoryFilter) {
                categoryFilter.value = currentCategoryFilter;
            }
        }
        function isGlowing(loc) {
            return loc.addedTime && (Date.now() - loc.addedTime) < 120000;
        }
        function createMarkerIcon(loc) {
            const isTextOnly = ['named locations', 'regions'].includes(loc.category);
            if (isTextOnly) {
                const words = loc.desc.split('\n')[0].trim().split(' ');
                const shortText = words.slice(0, 3).join(' ') + (words.length > 3 ? '...' : '');
                const width = Math.min(120, Math.max(60, shortText.length * 9));
                const glowStyle = isGlowing(loc) ? 'box-shadow: 0 0 8px #0f0, 0 0 16px #0f0, 0 0 24px #0f0; animation: pulse 1.5s infinite;' : '';
                const html = `<div style="background:#000; color:#fff; padding:3px 6px; border:2px solid #0f0; border-radius:4px; font-weight:bold; font-size:11px; white-space:nowrap; width:${width}px; text-align:center; overflow:hidden; text-overflow:ellipsis; ${glowStyle}">${escapeHtml(shortText)}</div>`;
                return L.divIcon({
                    className: 'text-marker',
                    html: html,
                    iconSize: [width + 12, 26],
                    iconAnchor: [(width + 12)/2, 13]
                });
            } else {
                const base = `<div class="marker-background" style="background-color:${categoryColors[loc.category] || '#808080'};">
                                <span style="font-size:18px;">${loc.icon}</span>
                              </div>`;
                return L.divIcon({
                    className: isGlowing(loc) ? 'custom-icon glowing' : 'custom-icon',
                    html: base,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
            }
        }
        const messageQueue = [];
        let activeMessageControl = null;
        function showTempMessage(html, ms = 3000) {
            messageQueue.push({ html, ms });
            if (!activeMessageControl) processMessageQueue();
        }
        function processMessageQueue() {
            if (messageQueue.length === 0 || activeMessageControl) return;
            const { html, ms } = messageQueue.shift();
            activeMessageControl = L.control({ position: 'bottomright' });
            activeMessageControl.onAdd = function() {
                const div = L.DomUtil.create('div', 'temp-message');
                div.innerHTML = html;
                div.style.cssText = 'background:rgba(0,0,0,0.85); color:#0f0; padding:8px 12px; border:1px solid #0f0; border-radius:6px; max-width:300px; font:bold 13px/1.4 monospace; box-shadow:0 0 10px #0f0; margin:10px; pointer-events:none; z-index:10000;';
                L.DomEvent.disableClickPropagation(div);
                return div;
            };
            activeMessageControl.addTo(map);
            setTimeout(() => {
                if (activeMessageControl) {
                    map.removeControl(activeMessageControl);
                    activeMessageControl = null;
                    processMessageQueue();
                }
            }, ms);
        }
        window.editMarkerFromPopup = function(index) {
            map.closePopup();
            openModal('Edit Item', index);
        };
        function attachDragHandler(marker, loc) {
            let isDragging = false;
            const onDragging = (e) => {
                if (!isDragging) return;
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                const latlng = map.mouseEventToLatLng({ clientX: clientX, clientY: clientY });
                marker.setLatLng(latlng);
            };
            const onDragEnd = () => {
                if (!isDragging) return;
                isDragging = false;
                isDraggingAny = false;
                map.dragging.enable();
                L.DomUtil.removeClass(marker._icon, 'dragging');
                L.DomEvent.off(document, 'mousemove', onDragging);
                L.DomEvent.off(document, 'mouseup', onDragEnd);
                L.DomEvent.off(document, 'touchmove', onDragging);
                L.DomEvent.off(document, 'touchend', onDragEnd);
                const newLatLng = marker.getLatLng();
                loc.lat = newLatLng.lat;
                loc.lng = newLatLng.lng;
                loc.desc = updateDescWithGrid(loc.desc, loc.lat, loc.lng);
                loc.addedTime = Date.now();
                loc.userEdited = true;
                if (loc.cid && !loc.userCid) loc.userCid = loc.cid;
                saveLocations();
                playSound('saving');
                showTempMessage(`Moved + saved! Lock to protect. ${loc.icon} ${loc.category}`, 4000);
                safeFlyTo(newLatLng.lat, newLatLng.lng, map.getZoom());
                forceReload();
            };
            const onDragStart = (e) => {
                if (loc.locked || isDraggingAny) return;
                if (e.touches) L.DomEvent.preventDefault(e);
                isDragging = true;
                isDraggingAny = true;
                map.dragging.disable();
                L.DomUtil.addClass(marker._icon, 'dragging');
                if (activeMessageControl) {
                    map.removeControl(activeMessageControl);
                    activeMessageControl = null;
                }
                L.DomEvent.on(document, 'mousemove', onDragging);
                L.DomEvent.on(document, 'mouseup', onDragEnd);
                L.DomEvent.on(document, 'touchmove', onDragging);
                L.DomEvent.on(document, 'touchend', onDragEnd);
            };
            marker.on('contextmenu', (e) => {
                L.DomEvent.stopPropagation(e);
                const index = locations.findIndex(l => l.id === marker.options.id);
                if (index !== -1) {
                    map.closePopup();
                    openModal('Edit Item', index);
                    playSound('click');
                }
            });
            if (!loc.locked) {
                marker.on('dragstart', onDragStart);
            }
            marker.bindPopup(`
                <b>${loc.icon} ${loc.category.toUpperCase()}</b><br>
                <div style="max-height:80px; overflow-y:auto; margin:4px 0; padding-right:8px;">
                    ${escapeHtml(loc.desc)}
                </div>
                <button onclick="editMarkerFromPopup(${locations.indexOf(loc)})"
                        style="margin-top:6px; padding:4px 10px; background:#00ff00; color:#000; border:none; border-radius:4px; cursor:pointer; font-weight:bold; font-size:12px;">
                    Edit
                </button>
            `, { maxWidth: 260, autoPan: true });
        }
        function addMarkerToMap(loc) {
            const marker = L.marker([loc.lat, loc.lng], {
                icon: createMarkerIcon(loc),
                id: loc.id,
                draggable: !loc.locked
            });
            attachDragHandler(marker, loc);
            const isTextOnly = ['named locations', 'regions'].includes(loc.category);
            if (clusteringEnabled && !isTextOnly) {
                clusteredMarkers.addLayer(marker);
            } else {
                nonClusteredMarkers.addLayer(marker);
            }
            if (isGlowing(loc)) {
                setTimeout(() => {
                    marker.setZIndexOffset(10000);
                    marker.setIcon(createMarkerIcon(loc));
                }, 100);
            }
        }
        function updateCounterDisplay() {
            const latestVersion = localStorage.getItem(MAP_VERSION_KEY) || "1.0";
            const totalFiltered = locations.filter(l => activeCategories.has(l.category)).length;
            const pageItems = locations.filter(l => activeCategories.has(l.category)).slice((tablePage - 1) * pageSize, tablePage * pageSize).length;
            if (counter) counter.innerHTML = `<strong>Map Version ${latestVersion}</strong> - <strong>${totalFiltered}</strong> logged locations - <strong>${pageItems}</strong> showing.`;
        }
        function refreshTable(search = '', catFilter = '') {
            const thead = document.querySelector('#locationsTable thead tr');
            if (thead) thead.innerHTML = '<th>Lock</th><th>Icon</th><th>Category</th><th>Description</th>';
            const tbody = document.querySelector('#locationsTable tbody');
            if (!tbody) return;
            tbody.innerHTML = '';
            const filtered = locations.filter(loc => {
                if (!activeCategories.has(loc.category)) return false;
                if (catFilter && loc.category !== catFilter) return false;
                if (!search) return true;
                return normalizeString(loc.desc).includes(normalizeString(search)) ||
                       normalizeString(loc.category).includes(normalizeString(search));
            });
            const glowing = filtered.filter(isGlowing).sort((a, b) => b.addedTime - a.addedTime);
            const normal = filtered.filter(loc => !isGlowing(loc)).sort((a, b) => {
                const catDiff = a.category.localeCompare(b.category);
                return catDiff !== 0 ? catDiff : a.desc.localeCompare(b.desc);
            });
            const sorted = [...glowing, ...normal];
            const start = (tablePage - 1) * pageSize;
            const pageItems = sorted.slice(start, start + pageSize);
            pageItems.forEach(loc => {
                const tr = document.createElement('tr');
                if (isGlowing(loc)) tr.classList.add('glowing');
                const shortDesc = loc.desc.split('\n')[0].trim();
                const lockEmoji = loc.locked ? 'üîê' : 'üîì';
                const lockCell = `<td><span style="font-size:18px; cursor:pointer;" onclick="toggleLockFromTable(${locations.indexOf(loc)})" title="${loc.locked ? 'Locked' : 'Unlocked'}">${lockEmoji}</span></td>`;
                const iconCell = ['named locations', 'regions'].includes(loc.category)
                    ? `<td><div style="background:#000; color:#fff; padding:2px 6px; border:1px solid #0f0; border-radius:3px; font-weight:bold; font-size:11px; display:inline-block; max-width:100px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(shortDesc)}</div></td>`
                    : `<td><div style="background-color:${categoryColors[loc.category] || '#808080'}; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; color:#000; font-weight:bold; font-size:16px;">${loc.icon}</div></td>`;
                const catCell = `<td>${escapeHtml(loc.category)} ${loc.icon}</td>`;
                const descCell = `<td style="text-align:left; padding-left:15px;">${escapeHtml(shortDesc)}</td>`;
                tr.innerHTML = lockCell + iconCell + catCell + descCell;
                tr.onclick = (e) => {
                    if (e.target.tagName === 'SPAN') return;
                    e.preventDefault();
                    const mapEl = document.getElementById('map');
                    if (mapEl) mapEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        safeFlyTo(loc.lat, loc.lng, 2);
                        playSound('click');
                    }, 300);
                };
                tr.oncontextmenu = (e) => {
                    e.preventDefault();
                    const mapEl = document.getElementById('map');
                    if (mapEl) mapEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        safeFlyTo(loc.lat, loc.lng, 2);
                        openModal('Edit Item', locations.findIndex(l => l.id === loc.id));
                    }, 300);
                };
                tbody.appendChild(tr);
            });
            const totalPages = Math.ceil(sorted.length / pageSize);
            tablePage = Math.min(tablePage, totalPages || 1);
            if (pageInfo) pageInfo.textContent = `Page ${tablePage} of ${totalPages || 1}`;
            if (prevPageBtn) prevPageBtn.disabled = tablePage <= 1;
            if (nextPageBtn) nextPageBtn.disabled = tablePage >= totalPages;
            updateCounterDisplay();
        }
        window.toggleLockFromTable = function(index) {
            const loc = locations[index];
            loc.locked = !loc.locked;
            saveLocations();
            forceReload();
            showTempMessage(loc.locked ? 'Marker locked ‚Äî unlock to edit!' : 'Marker unlocked!', 4000);
            playSound('click');
        };
        setInterval(() => {
            if (document.visibilityState === 'visible') {
                [clusteredMarkers, nonClusteredMarkers].forEach(group => {
                    group.eachLayer(marker => {
                        const loc = locations.find(l => l.id === marker.options.id);
                        if (loc) {
                            const shouldGlow = isGlowing(loc);
                            const currentIcon = marker.getIcon();
                            if (shouldGlow && !currentIcon.options.className.includes('glowing')) {
                                marker.setIcon(createMarkerIcon(loc));
                                marker.setZIndexOffset(10000);
                            } else if (!shouldGlow && currentIcon.options.className.includes('glowing')) {
                                marker.setIcon(createMarkerIcon(loc));
                                marker.setZIndexOffset(0);
                            }
                            if (loc.locked) {
                                marker.dragging?.disable();
                            } else {
                                marker.dragging?.enable();
                            }
                        }
                    });
                });
                refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
            }
        }, 1000);
        function openModal(title, index = -1, isDupe = false) {
            if (!modalTitle) return;
            modalTitle.innerHTML = `${title} <span id="modalLockToggle" style="font-size:22px; cursor:pointer; margin-left:10px;"></span>`;
            currentIndex = index;
            document.getElementById('saveItemBtn').style.display = 'inline-block';
            const lockToggle = document.getElementById('modalLockToggle');
            if (index >= 0 && !isDupe) {
                const loc = locations[index];
                if (itemCategorySelect) itemCategorySelect.value = loc.category || 'misc';
                if (itemDescInput) itemDescInput.value = loc.desc || '';
                if (itemCategorySelect) itemCategorySelect.disabled = loc.locked;
                if (itemDescInput) itemDescInput.disabled = loc.locked;
                if (deleteBtn) deleteBtn.style.display = loc.locked ? 'none' : 'inline-block';
                if (duplicateBtn) duplicateBtn.style.display = loc.locked ? 'none' : 'inline-block';
                if (undoBtn) undoBtn.style.display = lastDeleted ? 'inline-block' : 'none';
                if (shareItemBtn) shareItemBtn.style.display = 'inline-block';
                if (lockToggle) {
                    lockToggle.textContent = loc.locked ? 'üîê' : 'üîì';
                    lockToggle.title = loc.locked ? 'Locked ‚Äî click to unlock' : 'Unlocked ‚Äî click to lock';
                    lockToggle.onclick = (e) => {
                        e.stopPropagation();
                        loc.locked = !loc.locked;
                        lockToggle.textContent = loc.locked ? 'üîê' : 'üîì';
                        lockToggle.title = loc.locked ? 'Locked ‚Äî click to unlock' : 'Unlocked ‚Äî click to lock';
                        if (itemCategorySelect) itemCategorySelect.disabled = loc.locked;
                        if (itemDescInput) itemDescInput.disabled = loc.locked;
                        if (deleteBtn) deleteBtn.style.display = loc.locked ? 'none' : 'inline-block';
                        if (duplicateBtn) duplicateBtn.style.display = loc.locked ? 'none' : 'inline-block';
                        saveLocations();
                        forceReload();
                        showTempMessage(loc.locked ? 'Marker locked ‚Äî unlock to edit!' : 'Marker unlocked!', 4000);
                        playSound('click');
                    };
                    lockToggle.style.display = 'inline';
                }
            } else {
                if (itemCategorySelect) itemCategorySelect.value = 'misc';
                if (itemDescInput) itemDescInput.value = '';
                if (itemCategorySelect) itemCategorySelect.disabled = false;
                if (itemDescInput) itemDescInput.disabled = false;
                if (deleteBtn) deleteBtn.style.display = 'none';
                if (duplicateBtn) duplicateBtn.style.display = 'none';
                if (undoBtn) undoBtn.style.display = 'none';
                if (shareItemBtn) shareItemBtn.style.display = 'none';
                if (lockToggle) lockToggle.style.display = 'none';
            }
            if (itemModal) itemModal.style.display = 'block';
            document.body.classList.add('modal-open');
            playSound('click');
        }
        function closeModal(modal) {
            if (modal) modal.style.display = 'none';
            document.body.classList.remove('modal-open');
            playSound('modalClose');
        }
        document.querySelectorAll('.modal .close').forEach(closeBtn => {
            closeBtn.onclick = () => closeModal(closeBtn.closest('.modal'));
        });
        function recalculateXP() {
            xp = locations.length * xpPerMarker;
            level = 1 + Math.floor(xp / xpPerLevel);
            xp = xp % xpPerLevel;
            if (xp < 0) xp = 0;
            localStorage.setItem('fo76_level', level);
            localStorage.setItem('fo76_xp', xp);
        }
        recalculateXP();
        function updateXPBar() {
            if (levelSpan) levelSpan.textContent = level;
            if (xpProgress) {
                xpProgress.value = xp;
                xpProgress.max = xpPerLevel;
            }
            if (xpText) xpText.textContent = `${xp} / ${xpPerLevel}`;
        }
        function loadData(search = '', catFilter = '') {
            clusteredMarkers.clearLayers();
            nonClusteredMarkers.clearLayers();
            const filtered = locations.filter(loc => activeCategories.has(loc.category) && (!catFilter || loc.category === catFilter) && (!search || normalizeString(loc.desc + loc.category).includes(normalizeString(search))));
            filtered.forEach(addMarkerToMap);
            refreshTable(search, catFilter);
            updateXPBar();
            drawGrid();
            saveAppState();
        }
        function forceReload() {
            saveAppState();
            loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
            renderCategoryToggles();
            updateCategoryDropdowns();
            refreshTableVisibility();
        }
        function saveAppState() {
            localStorage.setItem('currentSearch', combinedSearch ? combinedSearch.value : '');
            localStorage.setItem('currentCategoryFilter', categoryFilter ? categoryFilter.value : '');
            localStorage.setItem('tablePage', tablePage);
            localStorage.setItem('tableVisible', tableVisible);
            localStorage.setItem('clusteringEnabled', clusteringEnabled);
            localStorage.setItem('gridEnabled', gridEnabled);
            localStorage.setItem('currentMap', currentMap);
            localStorage.setItem(MAP_VERSION_KEY, communityVersion);
        }
        function saveLocations() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(locations));
            saveAppState();
        }
        function normalizeString(s) { return (s || '').toString().trim().toLowerCase(); }
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe.toString()
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        let flyTimeout;
        function safeFlyTo(lat, lng, zoom = 2) {
            if (typeof lat !== 'number' || typeof lng !== 'number' || isNaN(lat) || isNaN(lng)) return;
            if (lat < 0 || lat > 4096 || lng < 0 || lng > 4096) return;
            clearTimeout(flyTimeout);
            flyTimeout = setTimeout(() => {
                map.flyTo([lat, lng], zoom, { duration: 0.8 });
            }, 100);
        }
        if (exportBtn) {
            exportBtn.onclick = () => {
                playSound('saving');
                const wantsAll = confirm('Click **OK** to export **ALL** locations + custom categories.\n\nClick **Cancel** to export **USER-LOGGED** locations only.');
                const exportData = {
                    version: 1.0,
                    communityVersion: communityVersion,
                    customCategories: customCategories
                };
                let exportedCount = 0;
                if (wantsAll) {
                    exportData.locations = locations;
                    exportData.note = 'ALL logged locations (community + user)';
                    exportedCount = locations.length;
                } else {
                    exportData.locations = locations.filter(loc => loc.userEdited === true);
                    exportData.note = 'USER-ONLY locations (your edits only)';
                    exportedCount = exportData.locations.length;
                }
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const typeSuffix = wantsAll ? 'all' : 'user';
                link.download = `fallout76_${typeSuffix}_${exportData.locations.length}_locations_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                link.click();
                URL.revokeObjectURL(url);
                let report = wantsAll ? 'Exported **ALL** locations!' : 'Exported **USER-ONLY** locations!';
                report += `\n\n‚Ä¢ ${exportedCount} markers\n`;
                report += `‚Ä¢ ${Object.keys(customCategories).length} custom categories\n`;
                report += `‚Ä¢ Community version: ${communityVersion}`;
                alert(report);
            };
        }
        if (importBtn) {
            importBtn.onclick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = e => {
                    const file = e.target?.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = ev => {
                        backupBeforeImport();
                        try {
                            const data = JSON.parse(ev.target.result);
                            const incoming = data.locations || [];
                            const existingByCid = new Map();
                            const existingByKey = new Map();
                            const userEditedCids = new Set();
                            const userEditedKeys = new Set();
                            locations.forEach(l => {
                                if (l.cid) {
                                    existingByCid.set(l.cid, l);
                                    if (l.userEdited) userEditedCids.add(l.cid);
                                } else {
                                    const key = `${l.desc}|${Math.round(l.lat)}|${Math.round(l.lng)}`;
                                    existingByKey.set(key, l);
                                    if (l.userEdited) userEditedKeys.add(key);
                                }
                            });
                            const seenCids = new Set();
                            for (const imp of incoming) {
                                if (imp.cid && seenCids.has(imp.cid)) {
                                    console.warn(`Skipping duplicate CID "${imp.cid}" in import file`);
                                    continue;
                                }
                                if (imp.cid) seenCids.add(imp.cid);
                            }
                            const preserveEdits = confirm(
                                `IMPORT OPTIONS:\n\n` +
                                `‚Ä¢ OK = PRESERVE your edits/moves\n` +
                                `‚Ä¢ CANCEL = RESET ALL community markers to original\n\n` +
                                `Choose wisely.`
                            );
                            const toAdd = [];
                            const toReplace = [];
                            let skippedUserEdited = 0;
                            let resetCount = 0;
                            let addedCount = 0;
                            let updatedCount = 0;
                            let movedCount = 0;
                            let descChangedCount = 0;
                            let catChangedCount = 0;
                            incoming.forEach(imp => {
                                if (seenCids.has(imp.cid) && incoming.filter(i => i.cid === imp.cid).length > 1) {
                                    return;
                                }
                                const newId = generateUniqueId();
                                const candidate = { ...imp, id: newId, addedTime: Date.now(), locked: imp.locked || false };
                                if (imp.cid) {
                                    const existing = existingByCid.get(imp.cid);
                                    if (!preserveEdits) {
                                        if (existing) {
                                            candidate.id = existing.id;
                                            toReplace.push(candidate);
                                            resetCount++;
                                            updatedCount++;
                                            if (Math.abs(existing.lat - imp.lat) > 1 || Math.abs(existing.lng - imp.lng) > 1) movedCount++;
                                            if (existing.desc !== imp.desc) descChangedCount++;
                                            if (existing.category !== imp.category) catChangedCount++;
                                        } else {
                                            candidate.userEdited = false;
                                            toAdd.push(candidate);
                                            addedCount++;
                                        }
                                        return;
                                    }
                                    if (existing && userEditedCids.has(imp.cid)) {
                                        existing.category = imp.category || existing.category;
                                        existing.icon = imp.icon || existing.icon;
                                        existing.addedTime = Date.now();
                                        existing.locked = imp.locked || false;
                                        skippedUserEdited++;
                                        return;
                                    }
                                    if (existing) {
                                        candidate.id = existing.id;
                                        toReplace.push(candidate);
                                        updatedCount++;
                                        if (Math.abs(existing.lat - imp.lat) > 1 || Math.abs(existing.lng - imp.lng) > 1) movedCount++;
                                        if (existing.desc !== imp.desc) descChangedCount++;
                                        if (existing.category !== imp.category) catChangedCount++;
                                    } else {
                                        candidate.userEdited = false;
                                        toAdd.push(candidate);
                                        addedCount++;
                                    }
                                    return;
                                }
                                const fallbackKey = `${imp.desc}|${Math.round(imp.lat)}|${Math.round(imp.lng)}`;
                                const existingFallback = existingByKey.get(fallbackKey);
                                if (!preserveEdits) {
                                    if (existingFallback) {
                                        candidate.id = existingFallback.id;
                                        toReplace.push(candidate);
                                        resetCount++;
                                        updatedCount++;
                                        if (Math.abs(existingFallback.lat - imp.lat) > 1 || Math.abs(existingFallback.lng - imp.lng) > 1) movedCount++;
                                        if (existingFallback.desc !== imp.desc) descChangedCount++;
                                        if (existingFallback.category !== imp.category) catChangedCount++;
                                    } else {
                                        candidate.userEdited = true;
                                        toAdd.push(candidate);
                                        addedCount++;
                                    }
                                    return;
                                }
                                if (existingFallback && userEditedKeys.has(fallbackKey)) {
                                    existingFallback.category = imp.category || existingFallback.category;
                                    existingFallback.icon = imp.icon || existing.icon;
                                    existingFallback.addedTime = Date.now();
                                    existingFallback.locked = imp.locked || false;
                                    skippedUserEdited++;
                                    return;
                                }
                                if (existingFallback) {
                                    candidate.id = existingFallback.id;
                                    toReplace.push(candidate);
                                    updatedCount++;
                                    if (Math.abs(existingFallback.lat - imp.lat) > 1 || Math.abs(existingFallback.lng - imp.lng) > 1) movedCount++;
                                    if (existingFallback.desc !== imp.desc) descChangedCount++;
                                    if (existingFallback.category !== imp.category) catChangedCount++;
                                } else {
                                    candidate.userEdited = true;
                                    toAdd.push(candidate);
                                    addedCount++;
                                }
                            });
                            const replaceIds = toReplace.map(r => r.id);
                            locations = locations.filter(l => !replaceIds.includes(l.id));
                            locations = [...locations, ...toAdd, ...toReplace];
                            let newCats = 0;
                            if (data.customCategories && typeof data.customCategories === 'object') {
                                Object.entries(data.customCategories).forEach(([name, emoji]) => {
                                    if (!customCategories[name] && !defaultCategoryIcons[name] && isValidEmoji(emoji)) {
                                        customCategories[name] = emoji;
                                        categoryIcons[name] = emoji;
                                        categoryColors[name] = '#f0e68c';
                                        activeCategories.add(name);
                                        newCats++;
                                    }
                                });
                            }
                            communityVersion = data.communityVersion || communityVersion;
                            localStorage.setItem(MAP_VERSION_KEY, communityVersion);
                            localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                            localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                            recalculateXP();
                            saveLocations();
                            setTimeout(() => {
                                forceReload();
                                updateCounterDisplay();
                            }, 100);
                            let report = `Imported ${incoming.length} markers from file!\n\n`;
                            if (addedCount) report += `+ ${addedCount} new markers added\n`;
                            if (updatedCount) report += `‚Üª ${updatedCount} markers updated\n`;
                            if (movedCount) report += ` ‚Ä¢ ${movedCount} moved\n`;
                            if (descChangedCount) report += ` ‚Ä¢ ${descChangedCount} description changes\n`;
                            if (catChangedCount) report += ` ‚Ä¢ ${catChangedCount} category changes\n`;
                            if (resetCount) report += `‚Ü∫ ${resetCount} community markers reset\n`;
                            if (skippedUserEdited) report += `‚úì ${skippedUserEdited} user edits preserved\n`;
                            if (newCats) report += `‚òÖ ${newCats} new custom categories\n`;
                            report += `\nTotal locations: ${locations.length}\n`;
                            report += `Community version: ${communityVersion}`;
                            alert(report);
                            playSound('saving');
                        } catch (err) {
                            console.error('Import error:', err);
                            alert(`Error: ${err.message || 'Invalid JSON'}`);
                            playSound('error');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };
        }
        if (downloadCommunityBtn) {
            downloadCommunityBtn.onclick = () => {
                playSound('click');
                if (!confirm(
                    `UPDATE COMMUNITY MAP?\n\n` +
                    `‚Ä¢ Adds new locations\n` +
                    `‚Ä¢ Updates moved/changed community markers\n` +
                    `‚Ä¢ YOUR edits & personal markers are 100% SAFE\n\n` +
                    `Continue?`
                )) return;
                downloadCommunityBtn.disabled = true;
                downloadCommunityBtn.textContent = 'Updating...';
                const url = `https://raw.githubusercontent.com/0mrcrazy0/fallout76-itemfindermap-beta/main/communitymap.json`;
                fetchWithTimeout(url)
                    .then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        return r.text();
                    })
                    .then(text => {
                        backupBeforeImport();
                        try {
                            const data = JSON.parse(text);
                            const incoming = data.locations || [];
                            const existingByCid = new Map();
                            const existingByKey = new Map();
                            const userEditedCids = new Set();
                            const userEditedKeys = new Set();
                            locations.forEach(l => {
                                if (l.cid) {
                                    existingByCid.set(l.cid, l);
                                    if (l.userEdited) userEditedCids.add(l.cid);
                                } else {
                                    const key = `${l.desc}|${Math.round(l.lat)}|${Math.round(l.lng)}`;
                                    existingByKey.set(key, l);
                                    if (l.userEdited) userEditedKeys.add(key);
                                }
                            });
                            const seenCids = new Set();
                            for (const imp of incoming) {
                                if (imp.cid && seenCids.has(imp.cid)) {
                                    console.warn(`Skipping duplicate CID "${imp.cid}" in community update`);
                                    continue;
                                }
                                if (imp.cid) seenCids.add(imp.cid);
                            }
                            const preserveEdits = true;
                            const toAdd = [];
                            const toReplace = [];
                            let skippedUserEdited = 0;
                            let addedCount = 0;
                            let updatedCount = 0;
                            let movedCount = 0;
                            let descChangedCount = 0;
                            let catChangedCount = 0;
                            incoming.forEach(imp => {
                                if (seenCids.has(imp.cid) && incoming.filter(i => i.cid === imp.cid).length > 1) {
                                    return;
                                }
                                const newId = generateUniqueId();
                                const candidate = { ...imp, id: newId, addedTime: Date.now(), locked: imp.locked || false };
                                if (imp.cid) {
                                    const existing = existingByCid.get(imp.cid);
                                    if (existing && userEditedCids.has(imp.cid)) {
                                        existing.category = imp.category || existing.category;
                                        existing.icon = imp.icon || existing.icon;
                                        existing.addedTime = Date.now();
                                        existing.locked = imp.locked || false;
                                        skippedUserEdited++;
                                        return;
                                    }
                                    if (existing) {
                                        candidate.id = existing.id;
                                        toReplace.push(candidate);
                                        updatedCount++;
                                        if (Math.abs(existing.lat - imp.lat) > 1 || Math.abs(existing.lng - imp.lng) > 1) movedCount++;
                                        if (existing.desc !== imp.desc) descChangedCount++;
                                        if (existing.category !== imp.category) catChangedCount++;
                                    } else {
                                        candidate.userEdited = false;
                                        toAdd.push(candidate);
                                        addedCount++;
                                    }
                                    return;
                                }
                                const fallbackKey = `${imp.desc}|${Math.round(imp.lat)}|${Math.round(imp.lng)}`;
                                const existingFallback = existingByKey.get(fallbackKey);
                                if (existingFallback && userEditedKeys.has(fallbackKey)) {
                                    existingFallback.category = imp.category || existingFallback.category;
                                    existingFallback.icon = imp.icon || existing.icon;
                                    existingFallback.addedTime = Date.now();
                                    existingFallback.locked = imp.locked || false;
                                    skippedUserEdited++;
                                    return;
                                }
                                if (existingFallback) {
                                    candidate.id = existingFallback.id;
                                    toReplace.push(candidate);
                                    updatedCount++;
                                    if (Math.abs(existingFallback.lat - imp.lat) > 1 || Math.abs(existingFallback.lng - imp.lng) > 1) movedCount++;
                                    if (existingFallback.desc !== imp.desc) descChangedCount++;
                                    if (existingFallback.category !== imp.category) catChangedCount++;
                                } else {
                                    candidate.userEdited = true;
                                    toAdd.push(candidate);
                                    addedCount++;
                                }
                            });
                            const replaceIds = toReplace.map(r => r.id);
                            locations = locations.filter(l => !replaceIds.includes(l.id));
                            locations = [...locations, ...toAdd, ...toReplace];
                            let newCats = 0;
                            if (data.customCategories && typeof data.customCategories === 'object') {
                                Object.entries(data.customCategories).forEach(([name, emoji]) => {
                                    if (!customCategories[name] && !defaultCategoryIcons[name] && isValidEmoji(emoji)) {
                                        customCategories[name] = emoji;
                                        categoryIcons[name] = emoji;
                                        categoryColors[name] = '#f0e68c';
                                        activeCategories.add(name);
                                        newCats++;
                                    }
                                });
                            }
                            communityVersion = data.communityVersion || communityVersion;
                            localStorage.setItem(MAP_VERSION_KEY, communityVersion);
                            localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                            localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                            recalculateXP();
                            saveLocations();
                            setTimeout(() => {
                                forceReload();
                                updateCounterDisplay();
                            }, 100);
                            let report = `Community Map Updated!\nVersion: ${communityVersion}\n\n`;
                            if (addedCount) report += `+ ${addedCount} new markers added\n`;
                            if (updatedCount) report += `‚Üª ${updatedCount} markers updated\n`;
                            if (movedCount) report += ` ‚Ä¢ ${movedCount} moved\n`;
                            if (descChangedCount) report += ` ‚Ä¢ ${descChangedCount} description changes\n`;
                            if (catChangedCount) report += ` ‚Ä¢ ${catChangedCount} category changes\n`;
                            if (skippedUserEdited) report += `‚úì ${skippedUserEdited} user edits preserved\n`;
                            report += `\nTotal locations: ${locations.length}`;
                            alert(report);
                            playSound('saving');
                        } catch (err) {
                            console.error('Community update error:', err);
                            alert(`Update failed: ${err.message}`);
                            playSound('error');
                        }
                    })
                    .catch(err => {
                        alert(`Update failed: ${err.message}\n\nCheck internet or file.`);
                        playSound('error');
                    })
                    .finally(() => {
                        if (downloadCommunityBtn) {
                            downloadCommunityBtn.disabled = false;
                            downloadCommunityBtn.textContent = 'Update Community Map';
                        }
                    });
            };
        }
        function backupBeforeImport() {
            lastImportBackup = {
                locations: JSON.parse(JSON.stringify(locations)),
                customCategories: { ...customCategories },
                communityVersion: communityVersion,
                activeCategories: new Set(activeCategories)
            };
            if (undoImportBtn) undoImportBtn.style.display = 'inline-block';
            showTempMessage('Import backup saved. Use "Undo Import" if needed.', 4000);
        }
        function undoLastImport() {
            if (!lastImportBackup) {
                alert("No import to undo.");
                return;
            }
            if (!confirm("Undo last import? This will restore your previous state.")) return;
            locations = lastImportBackup.locations;
            customCategories = lastImportBackup.customCategories;
            communityVersion = lastImportBackup.communityVersion;
            activeCategories = lastImportBackup.activeCategories;
            localStorage.setItem(STORAGE_KEY, JSON.stringify(locations));
            localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
            localStorage.setItem(MAP_VERSION_KEY, communityVersion);
            localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
            lastImportBackup = null;
            if (undoImportBtn) undoImportBtn.style.display = 'none';
            recalculateXP();
            forceReload();
            updateCounterDisplay();
            showTempMessage('Import undone! Previous state restored.', 4000);
            playSound('undo');
        }
        if (undoImportBtn) undoImportBtn.onclick = undoLastImport;
        if (saveJpegBtn) {
            saveJpegBtn.onclick = () => {
                playSound('saving');
                html2canvas(document.getElementById('map'), { useCORS: true, scale: 2 }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `fallout76_map_${new Date().toISOString().replace(/[:.]/g, '-')}.jpg`;
                    link.href = canvas.toDataURL('image/jpeg', 0.9);
                    link.click();
                    alert('Map saved as JPEG. Check your downloads folder!');
                }).catch(err => {
                    console.error(err);
                    alert('Failed to save map as JPEG.');
                    playSound('error');
                });
            };
        }
        if (prevPageBtn) {
            prevPageBtn.onclick = () => {
                if (tablePage > 1) {
                    tablePage--;
                    localStorage.setItem('tablePage', tablePage);
                    refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                    playSound('click');
                }
            };
        }
        if (nextPageBtn) {
            nextPageBtn.onclick = () => {
                const total = Math.ceil(locations.filter(l => activeCategories.has(l.category)).length / pageSize);
                if (tablePage < total) {
                    tablePage++;
                    localStorage.setItem('tablePage', tablePage);
                    refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                    playSound('click');
                }
            };
        }
        if (toggleTableBtn) {
            toggleTableBtn.onclick = () => {
                tableVisible = !tableVisible;
                localStorage.setItem('tableVisible', tableVisible);
                refreshTableVisibility();
                playSound('click');
            };
        }
        if (toggleButtonGroup) {
            toggleButtonGroup.onclick = () => {
                const isHidden = buttonGroup.style.display === 'none';
                buttonGroup.style.display = isHidden ? 'flex' : 'none';
                toggleButtonGroup.textContent = isHidden ? 'Hide Tools' : 'Show Tools';
                playSound('click');
            };
        }
        toggleSoundsBtn.onclick = () => {
            soundsEnabled = !soundsEnabled;
            localStorage.setItem('soundsEnabled', soundsEnabled);
            toggleSoundsBtn.textContent = soundsEnabled ? 'Sounds: On' : 'Sounds: Off';
            playSound('click');
        };
        toggleClusterBtn.onclick = () => {
            clusteringEnabled = !clusteringEnabled;
            localStorage.setItem('clusteringEnabled', clusteringEnabled);
            toggleClusterBtn.textContent = `Clustering: ${clusteringEnabled ? 'On' : 'Off'}`;
            playSound('click');
            loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
        };
        toggleMapBtn.onclick = () => {
            currentMap = currentMap === 'named' ? 'noName' : 'named';
            localStorage.setItem('currentMap', currentMap);
            toggleMapBtn.textContent = currentMap === 'named' ? 'Show No-Name Map' : 'Show Named Map';
            map.removeLayer(imageOverlay);
            imageOverlay = L.imageOverlay(mapUrls[currentMap], imageBounds).addTo(map);
            playSound('saving');
        };
        toggleGridBtn.onclick = () => {
            gridEnabled = !gridEnabled;
            localStorage.setItem('gridEnabled', gridEnabled);
            toggleGridBtn.textContent = `Grid: ${gridEnabled ? 'On' : 'Off'}`;
            drawGrid();
            if (gridEnabled) {
                map.getContainer().classList.add('hover-coords');
            } else {
                map.getContainer().classList.remove('hover-coords');
                if (coordHoverControl) coordHoverControl.getContainer().classList.remove('show');
            }
            playSound('click');
        };
        toggleCategoryModalBtn.onclick = () => {
            if (categoryToggleModal) categoryToggleModal.style.display = 'block';
            document.body.classList.add('modal-open');
            renderCategoryToggles();
            playSound('selectcategory');
        };
        const selectAllBtn = document.getElementById('selectAllBtn');
        if (selectAllBtn) {
            selectAllBtn.onclick = () => {
                activeCategories = new Set(Object.keys(categoryIcons));
                localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                renderCategoryToggles();
                loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                playSound('click');
            };
        }
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        if (deselectAllBtn) {
            deselectAllBtn.onclick = () => {
                activeCategories = new Set();
                localStorage.setItem('activeCategories', JSON.stringify([]));
                renderCategoryToggles();
                loadData(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                playSound('click');
            };
        }
        const createCategoryBtn = document.getElementById('createCategoryBtn');
        if (createCategoryBtn) {
            createCategoryBtn.onclick = () => {
                const newName = document.getElementById('newCategoryName');
                const newEmoji = document.getElementById('newCategoryEmoji');
                if (newName) newName.value = '';
                if (newEmoji) newEmoji.value = '';
                const createModal = document.getElementById('createCategoryModal');
                if (createModal) createModal.style.display = 'block';
                playSound('click');
            };
        }
        const deleteCategoryBtn = document.getElementById('deleteCategoryBtn');
        if (deleteCategoryBtn) {
            deleteCategoryBtn.onclick = () => {
                const select = document.getElementById('deleteCategorySelect');
                if (select) {
                    select.innerHTML = '<option value="">Select a custom category</option>';
                    Object.keys(customCategories).sort().forEach(name => {
                        const opt = document.createElement('option');
                        opt.value = name;
                        opt.textContent = `${name} ${customCategories[name]}`;
                        select.appendChild(opt);
                    });
                }
                const deleteModal = document.getElementById('deleteCategoryModal');
                if (deleteModal) deleteModal.style.display = 'block';
                playSound('click');
            };
        }
        const confirmDeleteCategoryBtn = document.getElementById('confirmDeleteCategoryBtn');
        if (confirmDeleteCategoryBtn) {
            confirmDeleteCategoryBtn.onclick = () => {
                const select = document.getElementById('deleteCategorySelect');
                const name = select ? select.value : '';
                if (!name || !customCategories[name]) return;
                if (confirm(`Delete category "${name}"? All markers will be reassigned to "misc".`)) {
                    locations.forEach(loc => {
                        if (loc.category === name) loc.category = 'misc';
                    });
                    delete customCategories[name];
                    delete categoryIcons[name];
                    delete categoryColors[name];
                    activeCategories.delete(name);
                    localStorage.setItem(CUSTOM_CATEGORIES_KEY, JSON.stringify(customCategories));
                    localStorage.setItem('activeCategories', JSON.stringify([...activeCategories]));
                    saveLocations();
                    forceReload();
                    const deleteModal = document.getElementById('deleteCategoryModal');
                    if (deleteModal) deleteModal.style.display = 'none';
                    playSound('delete');
                }
            };
        }
        const closeCategoryToggleBtn = document.getElementById('closeCategoryToggleBtn');
        if (closeCategoryToggleBtn) {
            closeCategoryToggleBtn.onclick = () => {
                closeModal(categoryToggleModal);
            };
        }
        document.querySelectorAll('#createCategoryModal .close, #deleteCategoryModal .close').forEach(closeBtn => {
            closeBtn.onclick = () => closeModal(closeBtn.closest('.modal'));
        });
        const saveItemBtn = document.getElementById('saveItemBtn');
        if (saveItemBtn) {
            saveItemBtn.onclick = () => {
                const category = itemCategorySelect ? itemCategorySelect.value : 'misc';
                let desc = itemDescInput ? itemDescInput.value.trim() : '';
                if (!desc) {
                    const lat = currentIndex >= 0 ? locations[currentIndex].lat : tempLatLng.lat;
                    const lng = currentIndex >= 0 ? locations[currentIndex].lng : tempLatLng.lng;
                    const grid = getGridFromLatLng(lat, lng);
                    const x = Math.round(lng);
                    const y = Math.round(lat);
                    desc = grid ? `Grid ${grid} (X: ${x}, Y: ${y})` : `X: ${x}, Y: ${y}`;
                    if (itemDescInput) itemDescInput.value = desc;
                }
                if (!desc) return;
                const wasNewLog = currentIndex < 0;
                if (currentIndex >= 0) {
                    const loc = locations[currentIndex];
                    if (loc.locked) {
                        showTempMessage('Marker locked ‚Äî unlock to edit!', 4000);
                        playSound('error');
                        return;
                    }
                    const wasCommunity = !!loc.cid;
                    loc.category = category;
                    loc.desc = desc;
                    loc.icon = categoryIcons[category] || 'UNKNOWN';
                    loc.addedTime = Date.now();
                    loc.userEdited = true;
                    if (wasCommunity && !loc.userCid) loc.userCid = loc.cid;
                } else {
                    const newLoc = {
                        id: generateUniqueId(),
                        lat: tempLatLng.lat,
                        lng: tempLatLng.lng,
                        category,
                        desc,
                        icon: categoryIcons[category] || 'UNKNOWN',
                        addedTime: Date.now(),
                        userEdited: true,
                        locked: false,
                        cid: generateCid({ category, desc, lat: tempLatLng.lat, lng: tempLatLng.lng })
                    };
                    locations.push(newLoc);
                    recalculateXP();
                }
                closeModal(itemModal);
                saveLocations();
                playSound('saving');
                showTempMessage('Saved!', 2000);
                const finalLoc = currentIndex >= 0 ? locations[currentIndex] : locations[locations.length - 1];
                safeFlyTo(finalLoc.lat, finalLoc.lng, map.getZoom());
                forceReload();
                if (wasNewLog && categoryFilter) {
                    categoryFilter.value = '';
                }
                setTimeout(() => { isDraggingAny = false; }, 600);
            };
        }
        if (deleteBtn) {
            deleteBtn.onclick = () => {
                if (currentIndex >= 0) {
                    const loc = locations[currentIndex];
                    if (loc.locked) {
                        showTempMessage('Marker locked ‚Äî unlock to delete!', 4000);
                        playSound('error');
                        return;
                    }
                    lastDeleted = { ...loc };
                    locations.splice(currentIndex, 1);
                    recalculateXP();
                    closeModal(itemModal);
                    saveLocations();
                    forceReload();
                    if (undoBtn) undoBtn.style.display = 'inline-block';
                    showTempMessage('Deleted! Use Undo to restore.', 4000);
                    playSound('delete');
                }
            };
        }
        if (undoBtn) {
            undoBtn.onclick = () => {
                if (lastDeleted) {
                    locations.push(lastDeleted);
                    lastDeleted = null;
                    recalculateXP();
                    saveLocations();
                    forceReload();
                    undoBtn.style.display = 'none';
                    closeModal(itemModal);
                    showTempMessage('Undo successful!', 3000);
                    playSound('undo');
                }
            };
        }
        if (duplicateBtn) {
            duplicateBtn.onclick = () => {
                if (currentIndex >= 0) {
                    const loc = locations[currentIndex];
                    if (loc.locked) {
                        showTempMessage('Marker locked ‚Äî unlock to duplicate!', 4000);
                        playSound('error');
                        return;
                    }
                    const baseOffset = 40 / Math.pow(2, map.getZoom());
                    const angleStep = 60;
                    const dupCount = locations.filter(l => l.cid === loc.cid && l.id !== loc.id).length;
                    const angle = dupCount * angleStep * Math.PI / 180;
                    const offsetX = baseOffset * Math.cos(angle);
                    const offsetY = baseOffset * Math.sin(angle);
                    const newLat = loc.lat + offsetY;
                    const newLng = loc.lng + offsetX;
                    const newDesc = updateDescWithGrid(loc.desc, newLat, newLng);
                    const newCid = generateCid({
                        category: loc.category,
                        desc: newDesc,
                        lat: newLat,
                        lng: newLng
                    });
                    const newLoc = {
                        ...loc,
                        id: generateUniqueId(),
                        lat: newLat,
                        lng: newLng,
                        desc: newDesc,
                        addedTime: Date.now(),
                        userEdited: true,
                        locked: false,
                        cid: newCid
                    };
                    locations.push(newLoc);
                    recalculateXP();
                    saveLocations();
                    forceReload();
                    closeModal(itemModal);
                    safeFlyTo(newLoc.lat, newLoc.lng, map.getZoom());
                    showTempMessage('Duplicated ‚Äî Grid updated!', 3000);
                    playSound('duplicate');
                }
            };
        }
        if (shareItemBtn) {
            shareItemBtn.onclick = () => {
                const loc = locations[currentIndex];
                const lat = loc.lat.toFixed(0);
                const lng = loc.lng.toFixed(0);
                const grid = getGridFromLatLng(lat, lng);
                const desc = loc.desc.split('\n')[0].trim();
                const url = `${window.location.origin}${window.location.pathname}?lat=${lat}&lng=${lng}&grid=${grid}&desc=${encodeURIComponent(desc)}`;
                navigator.clipboard.writeText(url).then(() => {
                    showTempMessage('Share link copied!', 3000);
                    playSound('click');
                }).catch(() => {
                    prompt('Copy this link:', url);
                });
            };
        }
        if (categoryFilter) {
            categoryFilter.addEventListener('change', () => {
                const val = categoryFilter.value;
                localStorage.setItem('currentCategoryFilter', val);
                loadData(combinedSearch ? combinedSearch.value : '', val);
                playSound('selectcategory');
            });
        }
        map.on('dragstart', () => { isDraggingAny = true; });
        map.on('dragend', () => { setTimeout(() => { isDraggingAny = false; }, 400); });
        map.on('movestart', () => { isDraggingAny = true; });
        map.on('moveend', () => { setTimeout(() => { isDraggingAny = false; }, 400); });
        const coordHoverControl = L.control({ position: 'bottomleft' });
        coordHoverControl.onAdd = function() {
            const div = L.DomUtil.create('div', 'coord-hover');
            div.innerHTML = '';
            div.style.cssText = 'background:rgba(0,0,0,0.7); color:#0f0; padding:6px 10px; border:1px solid #0f0; border-radius:4px; font:bold 12px monospace; pointer-events:none; opacity:0; transition:opacity 0.3s; margin:10px;';
            return div;
        };
        coordHoverControl.addTo(map);
        const hoverCoordsHandler = (e) => {
            if (isDraggingAny) return;
            let lat, lng;
            if (e.touches) {
                const touch = e.touches[0];
                lat = map.mouseEventToLatLng({ clientX: touch.clientX, clientY: touch.clientY }).lat;
                lng = map.mouseEventToLatLng({ clientX: touch.clientX, clientY: touch.clientY }).lng;
            } else {
                lat = e.latlng.lat;
                lng = e.latlng.lng;
            }
            const grid = getGridFromLatLng(lat, lng);
            const x = Math.round(lng);
            const y = Math.round(lat);
            coordHoverControl.getContainer().innerHTML = `Grid: ${grid || 'N/A'} (X: ${x}, Y: ${y})`;
            coordHoverControl.getContainer().classList.add('show');
        };
        map.on('mousemove', hoverCoordsHandler);
        map.on('touchmove', hoverCoordsHandler);
        map.getContainer().addEventListener('mouseleave', () => {
            coordHoverControl.getContainer().classList.remove('show');
        });
        map.on('click', e => {
            if (isDraggingAny) {
                isDraggingAny = false;
                return;
            }
            if (!gridEnabled) {
                const lat = e.latlng.lat;
                const lng = e.latlng.lng;
                const grid = getGridFromLatLng(lat, lng);
                const x = Math.round(lng);
                const y = Math.round(lat);
                coordHoverControl.getContainer().innerHTML = `Grid: ${grid || 'N/A'} (X: ${x}, Y: ${y})`;
                coordHoverControl.getContainer().classList.add('show');
                setTimeout(() => coordHoverControl.getContainer().classList.remove('show'), 3000);
            }
            if (gridEnabled) {
                const grid = getGridFromLatLng(e.latlng.lat, e.latlng.lng);
                if (grid) showGridNotification(grid);
            }
            playSound('click');
        });
        map.on('contextmenu', e => {
            L.DomEvent.preventDefault(e);
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            const grid = getGridFromLatLng(lat, lng);
            const x = Math.round(lng);
            const y = Math.round(lat);
            const desc = grid ? `Grid ${grid} (X: ${x}, Y: ${y})` : `X: ${x}, Y: ${y}`;
            const url = `${window.location.origin}${window.location.pathname}?lat=${y}&lng=${x}&grid=${grid}&desc=${encodeURIComponent(desc)}`;
            navigator.clipboard.writeText(url).then(() => {
                showTempMessage('Right-click location copied!', 3000);
                playSound('click');
            }).catch(() => {
                prompt('Copy this link:', url);
            });
            if (grid) showGridNotification(grid);
        });
        map.on('dblclick', e => {
            L.DomEvent.stopPropagation(e);
            tempLatLng = { lat: e.latlng.lat, lng: e.latlng.lng };
            openModal('Log Item');
            playSound('click');
        });
        const edgePanBuffer = 50;
        let edgePanInterval = null;
        map.getContainer().addEventListener('mousemove', e => {
            if (isDraggingAny) return;
            const rect = map.getContainer().getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const w = rect.width;
            const h = rect.height;
            let dx = 0, dy = 0;
            if (x < edgePanBuffer) dx = -10;
            if (x > w - edgePanBuffer) dx = 10;
            if (y < edgePanBuffer) dy = -10;
            if (y > h - edgePanBuffer) dy = 10;
            if (dx || dy) {
                if (!edgePanInterval) {
                    edgePanInterval = setInterval(() => {
                        map.panBy([dx, dy]);
                    }, 50);
                }
            } else if (edgePanInterval) {
                clearInterval(edgePanInterval);
                edgePanInterval = null;
            }
        });
        map.getContainer().addEventListener('mouseleave', () => {
            if (edgePanInterval) {
                clearInterval(edgePanInterval);
                edgePanInterval = null;
            }
        });
        map.getContainer().addEventListener('touchmove', e => {
            if (isDraggingAny) return;
            const touch = e.touches[0];
            const rect = map.getContainer().getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const w = rect.width;
            const h = rect.height;
            let dx = 0, dy = 0;
            if (x < edgePanBuffer) dx = -15;
            if (x > w - edgePanBuffer) dx = 15;
            if (y < edgePanBuffer) dy = -15;
            if (y > h - edgePanBuffer) dy = 15;
            if (dx || dy) {
                map.panBy([dx, dy]);
            }
        });
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('lat') && urlParams.has('lng')) {
            const lat = parseFloat(urlParams.get('lat'));
            const lng = parseFloat(urlParams.get('lng'));
            const grid = urlParams.get('grid') || getGridFromLatLng(lat, lng);
            const desc = urlParams.get('desc') ? decodeURIComponent(urlParams.get('desc')) : '';
            setTimeout(() => {
                safeFlyTo(lat, lng, 3);
                showTempMessage(`Shared: ${desc || grid}`, 5000);
                playSound('click');
            }, 1000);
        }
        updateCategoryDropdowns();
        renderCategoryToggles();
        loadData(currentSearch, currentCategoryFilter);
        refreshTableVisibility();
        drawGrid();
        updateXPBar();
        window.addEventListener('resize', refreshTableVisibility);
        refreshTableVisibility();
        if (gridEnabled) {
            map.getContainer().classList.add('hover-coords');
        }
        setTimeout(() => {
            const mapContainer = document.getElementById('map');
            const tableContainer = document.getElementById('tableContainer');
            if (!mapContainer || !tableContainer) return;

            // CREATE TOP BAR FOR TITLE + TOGGLE (STATIC ABOVE MAP)
            const topBar = document.createElement('div');
            topBar.id = 'topBar';
            topBar.style.cssText = 'width:100%; max-width:90%; margin:20px auto 10px; text-align:center; display:flex; align-items:center; justify-content:center; gap:10px; background:rgba(0,0,0,0.6); border:2px solid #0f0; border-radius:10px; padding:10px; box-shadow:0 0 15px #0f0;';
            mapContainer.parentNode.insertBefore(topBar, mapContainer);

            // MOVE TITLE INTO TOP BAR
            const originalTitle = document.getElementById('mainTitle');
            if (originalTitle) {
                originalTitle.style.cssText = 'margin:0; font-size:20px; font-weight:bold; color:#0f0; text-shadow:0 0 8px #0f0; flex:1;';
                topBar.appendChild(originalTitle);
            }

            // USE YOUR EXISTING TOGGLE BUTTON (outside topBar)
            const titleToggleBtn = document.getElementById('toggleTitleBtn');
            if (titleToggleBtn) {
                titleToggleBtn.onclick = () => {
                    titleVisible = !titleVisible;
                    topBar.style.display = titleVisible ? 'flex' : 'none';
                    titleToggleBtn.textContent = titleVisible ? '-' : '+';
                    localStorage.setItem('titleVisible', titleVisible);
                    playSound('click');
                };
                // Apply initial
                topBar.style.display = titleVisible ? 'flex' : 'none';
            }

            // PUSH MAP DOWN
            mapContainer.style.marginTop = '80px'; // space for top bar

            // MOVE CONTROLS BELOW MAP
            const controlsWrapper = document.createElement('div');
            controlsWrapper.id = 'belowMapControls';
            controlsWrapper.style.cssText = 'width:100%; max-width:90%; margin:20px auto; display:flex; flex-direction:column; align-items:center; gap:15px;';

            const searchBarEl = document.getElementById('searchBar');
            if (searchBarEl) {
                controlsWrapper.appendChild(searchBarEl);
            }

            mapContainer.parentNode.insertBefore(controlsWrapper, tableContainer);

            // TOOLS TOGGLE ROW
            const toolsToggleRow = document.createElement('div');
            toolsToggleRow.id = 'toolsToggleRow';
            toolsToggleRow.style.cssText = 'width:100%; max-width:90%; margin:15px auto 0; display:flex; justify-content:center;';
            if (toggleButtonGroup && buttonGroup) {
                toolsToggleRow.appendChild(toggleButtonGroup);
            }
            mapContainer.parentNode.insertBefore(toolsToggleRow, controlsWrapper);

            // TOOL BUTTONS INTO CONTROLS
            if (buttonGroup) {
                buttonGroup.style.cssText = 'display:flex !important; flex-wrap:wrap !important; gap:8px !important; justify-content:center !important; margin:15px auto !important; padding:15px !important; background:rgba(0,0,0,0.5) !important; border:1px solid #0f0 !important; border-radius:8px !important; max-width:90% !important;';
                controlsWrapper.appendChild(buttonGroup);
            }

            // TOOLS TOGGLE LOGIC
            if (toggleButtonGroup && buttonGroup) {
                toggleButtonGroup.style.cssText = 'display:inline-block !important; background:#00ff00 !important; color:#000 !important; padding:8px 14px !important; border-radius:6px !important; font-weight:bold !important; cursor:pointer !important; font-size:14px !important; width:200px !important; text-align:center !important;';
                const toolsVisible = localStorage.getItem('toolsVisible') !== 'false';
                buttonGroup.style.display = toolsVisible ? 'flex' : 'none';
                toggleButtonGroup.textContent = toolsVisible ? 'Hide Tools' : 'Show Tools';
                toggleButtonGroup.onclick = () => {
                    const willShow = buttonGroup.style.display === 'none';
                    buttonGroup.style.display = willShow ? 'flex' : 'none';
                    toggleButtonGroup.textContent = willShow ? 'Hide Tools' : 'Show Tools';
                    localStorage.setItem('toolsVisible', willShow);
                    playSound('click');
                };
            }

            // VOICE SEARCH STYLE
            if (voiceSearchBtn && buttonGroup) {
                if (voiceSearchBtn.parentNode !== buttonGroup) {
                    buttonGroup.insertBefore(voiceSearchBtn, toggleClusterBtn);
                }
                voiceSearchBtn.style.cssText = 'display:inline-block !important; background:#00ff00 !important; color:#000 !important; padding:8px 14px !important; border-radius:6px !important; font-weight:bold !important; cursor:pointer !important; font-size:14px !important; min-width:120px !important; text-align:center !important;';
                voiceSearchBtn.textContent = 'Voice Search';
                voiceSearchBtn.title = 'Voice Search';
            }

            // COUNTER & PAGINATION
            if (counter && tableContainer) {
                let pagination = document.getElementById('tablePagination');
                if (!pagination) {
                    pagination = document.createElement('div');
                    pagination.id = 'tablePagination';
                    pagination.style.cssText = 'display:flex !important; justify-content:center !important; align-items:center !important; gap:12px !important; margin:15px 0 !important;';
                    if (prevPageBtn) pagination.appendChild(prevPageBtn);
                    if (pageInfo) pagination.appendChild(pageInfo);
                    if (nextPageBtn) pagination.appendChild(nextPageBtn);
                }
                const table = tableContainer.querySelector('#locationsTable');
                if (table) {
                    tableContainer.insertBefore(counter, table);
                    tableContainer.insertBefore(pagination, table);
                }
                counter.style.cssText = 'display:block !important; text-align:center !important; width:100% !important; max-width:600px !important; margin:20px auto 8px !important; font-weight:bold !important; font-size:16px !important; background:rgba(0,0,0,0.6) !important; color:#0f0 !important; padding:12px !important; border:2px solid #0f0 !important; border-radius:10px !important;';
            }

            // CUSTOM HEADER
            let customHeader = document.getElementById('customTableHeader');
            if (!customHeader && tableContainer) {
                customHeader = document.createElement('div');
                customHeader.id = 'customTableHeader';
                customHeader.style.cssText = 'display: table !important; width: 100% !important; table-layout: fixed !important; border-spacing: 0 12px !important; margin-bottom: -12px !important;';
                customHeader.innerHTML = `
                    <div style="display: table-row !important; background: rgba(0, 255, 0, 0.2) !important; border: 1px solid #0f0 !important; border-radius: 8px !important;">
                        <div style="display: table-cell !important; width: 10% !important; padding: 10px !important; text-align: center !important; color: #0f0 !important; font-weight: bold !important;">Lock</div>
                        <div style="display: table-cell !important; width: 15% !important; padding: 10px !important; text-align: center !important; color: #0f0 !important; font-weight: bold !important;">Icon</div>
                        <div style="display: table-cell !important; width: 25% !important; padding: 10px !important; text-align: center !important; color: #0f0 !important; font-weight: bold !important;">Category</div>
                        <div style="display: table-cell !important; width: 50% !important; padding: 10px !important; text-align: center !important; color: #0f0 !important; font-weight: bold !important; padding-left: 15px !important;">Description</div>
                    </div>
                `;
                const table = tableContainer.querySelector('#locationsTable');
                if (table) tableContainer.insertBefore(customHeader, table);
            }

            // SEARCH BAR STYLE
            if (searchBarEl) searchBarEl.style.cssText = 'display:flex !important; align-items:center !important; gap:8px !important; flex-wrap:wrap !important; justify-content:center !important; margin:10px auto !important; padding:10px !important; background:rgba(0,0,0,0.5) !important; border:1px solid #0f0 !important; border-radius:8px !important; max-width:90% !important;';

            // TABLE STYLES
            const style = document.createElement('style');
            style.textContent = `
                #locationsTable { width: 100% !important; max-width: 100% !important; border-collapse: separate !important; border-spacing: 0 12px !important; table-layout: fixed !important; }
                #locationsTable thead { display: none !important; }
                #locationsTable tbody { display: block !important; width: 100% !important; }
                #locationsTable tbody tr { display: table-row !important; background: rgba(0, 0, 0, 0.4) !important; border: 1px solid #0f0 !important; border-radius: 8px !important; transition: all 0.3s ease !important; width: 100% !important; box-sizing: border-box !important; }
                #locationsTable tbody tr:hover { background: rgba(0, 255, 0, 0.08) !important; box-shadow: 0 0 8px #0f0 !important; }
                #locationsTable tbody tr.glowing { background: rgba(0, 255, 0, 0.15) !important; box-shadow: 0 0 12px #0f0, 0 0 20px #0f0 !important; order: -1 !important; }
                #locationsTable tbody td { padding: 10px !important; text-align: center !important; vertical-align: middle !important; word-wrap: break-word !important; }
                #locationsTable tbody td:nth-child(1) { width: 10% !important; }
                #locationsTable tbody td:nth-child(2) { width: 15% !important; }
                #locationsTable tbody td:nth-child(3) { width: 25% !important; }
                #locationsTable tbody td:nth-child(4) { width: 50% !important; text-align: left !important; padding-left: 15px !important; }
            `;
            document.head.appendChild(style);

            // PAGINATION RE-ATTACH
            if (prevPageBtn) {
                prevPageBtn.onclick = () => {
                    if (tablePage > 1) {
                        tablePage--;
                        localStorage.setItem('tablePage', tablePage);
                        refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                        playSound('click');
                    }
                };
            }
            if (nextPageBtn) {
                nextPageBtn.onclick = () => {
                    const total = Math.ceil(locations.filter(l => activeCategories.has(l.category)).length / pageSize);
                    if (tablePage < total) {
                        tablePage++;
                        localStorage.setItem('tablePage', tablePage);
                        refreshTable(combinedSearch ? combinedSearch.value : '', categoryFilter ? categoryFilter.value : '');
                        playSound('click');
                    }
                };
            }
            document.body.classList.add('map-ready');
        }, 1000);
    })();
});
     /* --------------------------------------------------------------------------
           Fallout 76 Item Finder Map Version 36 - Disclaimer and Terms of Use
           --------------------------------------------------------------------------
           Copyright (c) 2025 MrCrazy. All rights reserved.
           This application, including all code, design, content, and the map images is the intellectual property of MrCrazy.
           Unauthorized use, copying, modification, distribution, or monetization of this application or any part thereof is strictly prohibited without explicit written permission from the author.
           This app is provided "as is" for personal, non-commercial use by Fallout 76 players to track in-game items.
           The author is not responsible for any damages or losses resulting from the use of this application. Use at your own risk.
           For inquiries or permission requests, call someone who cares.
           Last updated: November 03, 2025
           -------------------------------------------------------------------------- */
</script>
</body>
</html>

